<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Header di sicurezza -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff" />
    <meta http-equiv="X-Frame-Options" content="DENY" />
    <meta http-equiv="X-XSS-Protection" content="1; mode=block" />
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; img-src 'self' data: https:; connect-src 'self' https://hvviecqurdbpxxfmaapb.supabase.co; font-src 'self' https://cdn.jsdelivr.net; object-src 'none'; base-uri 'self';" />
    <title>Gestione Campionato - Falco Sabaudo</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <style>
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button:hover {
            color: #fbbf24;
        }
        .tab-button.active {
            color: #fbbf24;
            border-bottom-color: #fbbf24;
        }
        .standings-table {
            font-size: 0.9rem;
        }
        .standings-table th,
        .standings-table td {
            padding: 0.5rem 0.25rem;
        }
        @media (max-width: 768px) {
            .standings-table {
                font-size: 0.8rem;
            }
            .standings-table th,
            .standings-table td {
                padding: 0.25rem 0.125rem;
            }
        }
    </style>
</head>

<body class="bg-green-900 text-white">
    <header class="text-center py-8">
        <img src="assets/logo.svg" alt="Logo Falco Sabaudo" class="mx-auto w-32 mb-4" />
        <h1 class="text-3xl font-bold">Gestione Campionato</h1>
        <nav class="mt-4">
            <a href="index.html" class="text-yellow-400 underline text-lg">‚Üê Torna alla Home</a>
        </nav>
    </header>

    <main class="px-6 max-w-6xl mx-auto">
        
        <!-- Sezione Pubblica - Consultazione Campionati -->
        <section id="public-section" class="my-12">
            <h2 class="text-2xl font-semibold mb-6 text-yellow-400">Consulta Campionati</h2>
            <p class="text-gray-300 mb-6">Visualizza classifica e calendario dei campionati in corso</p>
            
            <!-- Selezione campionato pubblico -->
            <div class="bg-green-800 p-6 rounded shadow mb-8">
                <label class="block text-sm mb-2">Seleziona Campionato</label>
                <select id="public-competition-select" class="w-full p-3 rounded bg-green-900 text-white border border-yellow-400 text-lg">
                    <option value="">Seleziona un campionato per visualizzare classifica e calendario...</option>
                </select>
            </div>

            <!-- Navigazione tab pubblici -->
            <nav class="mb-8" id="public-tabs" style="display: none;">
                <ul class="flex space-x-4 border-b border-yellow-400">
                    <li><button id="public-tab-standings" class="tab-button px-4 py-2 text-yellow-400 border-b-2 border-yellow-400 font-semibold">Classifica</button></li>
                    <li><button id="public-tab-calendar" class="tab-button px-4 py-2 text-gray-300 hover:text-yellow-400">Calendario</button></li>
                    <li><button id="public-tab-stats" class="tab-button px-4 py-2 text-gray-300 hover:text-yellow-400">Statistiche</button></li>
                </ul>
            </nav>

            <!-- Tab Classifica Pubblica -->
            <div id="public-standings-tab" class="tab-content">
                <div class="bg-green-800 p-6 rounded shadow">
                    <h3 class="text-xl font-semibold mb-4 text-yellow-400">Classifica</h3>
                    <div id="public-standings-content">
                        <p class="text-gray-400 italic">Seleziona un campionato per visualizzare la classifica</p>
                    </div>
                </div>
            </div>

            <!-- Tab Calendario Pubblico -->
            <div id="public-calendar-tab" class="tab-content hidden">
                <div class="bg-green-800 p-6 rounded shadow">
                    <h3 class="text-xl font-semibold mb-4 text-yellow-400">Calendario</h3>
                    <div id="public-calendar-content">
                        <p class="text-gray-400 italic">Seleziona un campionato per visualizzare il calendario</p>
                    </div>
                </div>
            </div>

            <!-- Tab Statistiche Pubbliche -->
            <div id="public-stats-tab" class="tab-content hidden">
                <div class="bg-green-800 p-6 rounded shadow">
                    <h3 class="text-xl font-semibold mb-4 text-yellow-400">Statistiche Squadre</h3>
                    <div id="public-stats-content">
                        <p class="text-gray-400 italic">Seleziona un campionato per visualizzare le statistiche</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Sezione di login -->
        <section id="auth-section" class="my-12 border-t border-yellow-400 pt-8">
            <div class="bg-green-800 p-6 rounded shadow text-center">
                <p class="mb-4">üîê Accesso Amministratori:</p>
                <input type="email" id="email" placeholder="Email" class="p-2 rounded w-64 bg-green-900 text-white border border-yellow-400 mb-2">
                <input type="password" id="password" placeholder="Password" class="p-2 rounded w-64 bg-green-900 text-white border border-yellow-400 mb-4">
                <br>
                <button id="login-btn" class="bg-yellow-400 text-green-900 px-4 py-2 rounded font-semibold hover:bg-yellow-300">Accedi</button>
                <p id="auth-message" class="text-sm mt-2"></p>
                <button id="logout-btn" class="mt-4 hidden bg-red-500 text-white px-4 py-2 rounded">Logout</button>
            </div>
        </section>

        <!-- Sezione Admin (visibile solo se autenticato) -->
        <section id="admin-section" class="my-12 border-t border-yellow-400 pt-8 hidden">
            <!-- Navigazione tab -->
            <nav class="mb-8">
                <ul class="flex space-x-4 border-b border-yellow-400">
                    <li><button id="tab-competitions" class="tab-button px-4 py-2 text-yellow-400 border-b-2 border-yellow-400 font-semibold">Campionati</button></li>
                    <li><button id="tab-calendar" class="tab-button px-4 py-2 text-gray-300 hover:text-yellow-400">Calendario</button></li>
                    <li><button id="tab-standings" class="tab-button px-4 py-2 text-gray-300 hover:text-yellow-400">Classifica</button></li>
                </ul>
            </nav>

            <!-- Tab Campionati -->
            <div id="competitions-tab" class="tab-content">
                <h2 class="text-2xl font-semibold mb-4 text-yellow-400">Gestione Campionati</h2>
                
                <!-- Form creazione campionato -->
                <div class="bg-green-800 p-6 rounded shadow mb-8">
                    <h3 class="text-xl font-semibold mb-4">Crea Nuovo Campionato</h3>
                    <form id="competition-form" class="space-y-4">
                        <div class="flex gap-4 items-end">
                            <div class="flex-1">
                                <label class="block text-sm mb-1">Nome Campionato</label>
                                <input type="text" id="competition-name" placeholder="Nome del campionato" required 
                                       class="w-full p-2 rounded bg-green-900 text-white border border-yellow-400">
                            </div>
                            <div>
                                <label class="block text-sm mb-1">Tipo</label>
                            <select id="competition-type" class="p-2 rounded bg-green-900 text-white border border-yellow-400">
                                <option value="all-against-all">Campionato all'italiana</option>
                                <option value="elimination">Eliminazione diretta</option>
                                <option value="cup">Coppa (Gironi + Finale)</option>
                            </select>
                        </div>
                        <div id="cup-groups-container" class="hidden">
                            <label class="block text-sm mb-1">Numero Gironi</label>
                            <select id="cup-groups" class="p-2 rounded bg-green-900 text-white border border-yellow-400">
                                <option value="2">2 Gironi</option>
                                <option value="4">4 Gironi</option>
                            </select>
                        </div>
                        <button type="submit" class="bg-yellow-400 text-green-900 px-6 py-2 rounded font-semibold hover:bg-yellow-300">
                            Crea Campionato
                        </button>
                    </div>
                </form>
            </div>

                <!-- Lista campionati -->
                <div class="bg-green-800 p-6 rounded shadow">
                    <h3 class="text-xl font-semibold mb-4">Campionati Esistenti</h3>
                    <div id="competitions-list" class="space-y-3">
                        <p class="text-gray-400 italic">Caricamento campionati...</p>
                    </div>
                </div>
            </div>

            <!-- Tab Calendario -->
            <div id="calendar-tab" class="tab-content hidden">
                <h2 class="text-2xl font-semibold mb-4 text-yellow-400">Calendario Giornate</h2>
                
                <!-- Selezione campionato -->
                <div class="bg-green-800 p-6 rounded shadow mb-8">
                    <label class="block text-sm mb-2">Seleziona Campionato</label>
                    <select id="calendar-competition-select" class="w-full p-2 rounded bg-green-900 text-white border border-yellow-400 mb-4">
                        <option value="">Seleziona un campionato...</option>
                    </select>
                    <div class="flex gap-2">
                        <button id="generate-calendar" class="bg-yellow-400 text-green-900 px-4 py-2 rounded font-semibold hover:bg-yellow-300">
                            Genera Calendario
                        </button>
                        <button id="generate-finals" class="bg-blue-600 text-white px-4 py-2 rounded font-semibold hover:bg-blue-700" style="display: none;">
                            Genera Fasi Finali
                        </button>
                        <button id="repair-finals" class="bg-orange-600 text-white px-4 py-2 rounded font-semibold hover:bg-orange-700" style="display: none;">
                            üîß Ripara Fasi Finali
                        </button>
                    </div>
                </div>

                <!-- Giornate -->
                <div id="calendar-content" class="space-y-6">
                    <p class="text-gray-400 italic">Seleziona un campionato per visualizzare il calendario</p>
                </div>
            </div>

            <!-- Tab Classifica -->
            <div id="standings-tab" class="tab-content hidden">
                <h2 class="text-2xl font-semibold mb-4 text-yellow-400">Classifica</h2>
                
                <!-- Selezione campionato -->
                <div class="bg-green-800 p-6 rounded shadow mb-8">
                    <label class="block text-sm mb-2">Seleziona Campionato</label>
                    <select id="standings-competition-select" class="w-full p-2 rounded bg-green-900 text-white border border-yellow-400 mb-4">
                        <option value="">Seleziona un campionato...</option>
                    </select>
                    <button id="recalculate-standings" class="bg-red-600 text-white px-4 py-2 rounded font-semibold hover:bg-red-500 mr-2">
                        üîÑ Ricalcola Classifica
                    </button>
                    <button id="recalculate-all-standings" class="bg-orange-600 text-white px-4 py-2 rounded font-semibold hover:bg-orange-500">
                        üîÑ Ricalcola Tutte le Classifiche
                    </button>
                </div>

                <!-- Classifica -->
                <div id="standings-content" class="bg-green-800 p-6 rounded shadow">
                    <p class="text-gray-400 italic">Seleziona un campionato per visualizzare la classifica</p>
                </div>
            </div>
        </section>
    </main>

    <!-- Modal per inserimento risultato partita -->
    <div id="match-result-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-lg p-6 w-full max-w-md">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-800">Inserisci Risultato</h3>
                    <button id="close-match-result-modal" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
                
                <div class="mb-4">
                    <p class="text-gray-700 mb-2"><strong>Partita:</strong></p>
                    <p id="match-teams" class="text-lg font-semibold text-gray-800"></p>
                </div>

                <form id="match-result-form">
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label id="home-team-label" class="block text-sm font-medium text-gray-700 mb-1"></label>
                            <input type="number" id="home-score" min="0" max="99" class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label id="away-team-label" class="block text-sm font-medium text-gray-700 mb-1"></label>
                            <input type="number" id="away-score" min="0" max="99" class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                    </div>

                    <div class="flex justify-end gap-2">
                        <button type="button" id="cancel-match-result" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
                            Annulla
                        </button>
                        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                            Salva Risultato
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Modal per aggiungere squadre dopo creazione campionato -->
    <div id="teams-creation-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-800">Aggiungi Squadre al Campionato</h3>
                    <button id="close-teams-creation-modal" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
                
                <div class="mb-4 p-3 bg-blue-50 rounded">
                    <p class="text-gray-700 mb-1"><strong>Campionato:</strong> <span id="creation-competition-name" class="font-semibold"></span></p>
                    <p class="text-gray-700"><strong>Tipo:</strong> <span id="creation-competition-type" class="font-semibold"></span></p>
                </div>

                <!-- Warning per numeri dispari -->
                <div id="odd-teams-warning" class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4 hidden">
                    <div class="flex">
                        <div class="py-1">
                            <svg class="fill-current h-6 w-6 text-yellow-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z"/>
                            </svg>
                        </div>
                        <div>
                            <p class="font-bold">Attenzione!</p>
                            <p class="text-sm">Un campionato all'italiana con un numero dispari di squadre richieder√† che una squadra riposi in ogni giornata.</p>
                        </div>
                    </div>
                </div>

                <form id="team-creation-form" class="mb-4">
                    <div class="flex gap-2">
                        <input type="text" id="new-team-name" placeholder="Nome squadra" required 
                               class="flex-1 px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button type="submit" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded">
                            Aggiungi
                        </button>
                    </div>
                </form>

                <div class="mb-4">
                    <h4 class="font-semibold text-gray-800 mb-2">Squadre aggiunte (<span id="teams-count">0</span>):</h4>
                    <div id="creation-teams-list" class="space-y-2 max-h-48 overflow-y-auto border rounded p-2">
                        <p class="text-gray-400 italic">Nessuna squadra aggiunta</p>
                    </div>
                </div>

                <div class="flex justify-end gap-2">
                    <button id="cancel-teams-creation" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
                        Annulla
                    </button>
                    <button id="finish-competition-creation" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                        Finalizza Campionato
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal per modifica campionato esistente -->
    <div id="edit-competition-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-800">Modifica Campionato</h3>
                    <button id="close-edit-modal" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
                
                <form id="edit-competition-form" class="mb-6 p-4 bg-gray-50 rounded">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">Nome Campionato</label>
                            <input type="text" id="edit-competition-name" required 
                                   class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">Tipo</label>
                            <select id="edit-competition-type" 
                                    class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all-against-all">Campionato all'italiana</option>
                                <option value="elimination">Eliminazione diretta</option>
                                <option value="cup">Coppa (Gironi + Finale)</option>
                            </select>
                        </div>
                    </div>
                    <div id="edit-cup-groups-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 hidden">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">Numero Gironi</label>
                            <select id="edit-cup-groups" 
                                    class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="2">2 Gironi</option>
                                <option value="4">4 Gironi</option>
                            </select>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
                            Aggiorna Info
                        </button>
                        <button type="button" id="edit-results-btn" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded">
                            Modifica Risultati
                        </button>
                    </div>
                </form>

                <!-- Warning per numeri dispari nella modifica -->
                <div id="edit-odd-teams-warning" class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4 hidden">
                    <div class="flex">
                        <div class="py-1">
                            <svg class="fill-current h-6 w-6 text-yellow-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z"/>
                            </svg>
                        </div>
                        <div>
                            <p class="font-bold">Attenzione!</p>
                            <p class="text-sm">Un campionato all'italiana con un numero dispari di squadre richieder√† che una squadra riposi in ogni giornata.</p>
                        </div>
                    </div>
                </div>

                <div class="mb-4">
                    <h4 class="font-semibold text-gray-800 mb-2">Gestione Squadre</h4>
                    <form id="edit-team-form" class="mb-4">
                        <div class="flex gap-2">
                            <input type="text" id="edit-new-team-name" placeholder="Nome nuova squadra" 
                                   class="flex-1 px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button type="submit" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded">
                                Aggiungi
                            </button>
                        </div>
                    </form>

                    <div class="mb-4">
                        <h5 class="font-medium text-gray-700 mb-2">Squadre nel campionato (<span id="edit-teams-count">0</span>):</h5>
                        <div id="edit-teams-list" class="space-y-2 max-h-48 overflow-y-auto border rounded p-2">
                            <p class="text-gray-400 italic">Caricamento squadre...</p>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end gap-2">
                    <button id="close-edit-competition" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
                        Chiudi
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal per modifica risultati campionato -->
    <div id="edit-results-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-800">Modifica Risultati - <span id="edit-results-competition-name"></span></h3>
                    <button id="close-edit-results-modal" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
                
                <div class="mb-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">Seleziona Giornata</label>
                    <select id="edit-results-matchday-select" class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="">Caricamento giornate...</option>
                    </select>
                </div>

                <div id="edit-results-matches-container" class="space-y-4">
                    <p class="text-gray-500 italic">Seleziona una giornata per vedere le partite</p>
                </div>

                <div class="flex justify-end gap-2 mt-6">
                    <button id="close-edit-results" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
                        Chiudi
                    </button>
                    <button id="save-all-results" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded hidden">
                        Salva Tutti i Risultati
                    </button>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center py-6 text-sm text-green-300">
        ¬© 2025 OSC Falco Sabaudo. Tutti i diritti riservati.
    </footer>

    <script>
        console.log('üöÄ Campionato: Script iniziato');
        
        // Variabili globali
        let supabaseClient = null;
        let logoutTimer = null;
        let loginAttempts = 0;
        let lastLoginAttempt = 0;

        // Timer per logout automatico (30 minuti di inattivit√†)
        function resetLogoutTimer() {
            if (logoutTimer) {
                clearTimeout(logoutTimer);
            }
            logoutTimer = setTimeout(async () => {
                try {
                    await logout();
                    const adminSection = document.getElementById('admin-section');
                    const logoutBtn = document.getElementById('logout-btn');
                    adminSection.classList.add('hidden');
                    logoutBtn.classList.add('hidden');
                    showError('Sessione scaduta per inattivit√†. Effettua nuovamente il login.');
                } catch (error) {
                    console.error('Errore logout automatico:', error);
                }
            }, 30 * 60 * 1000); // 30 minuti
        }

        // Attiva il timer su qualsiasi attivit√† dell'utente
        function setupActivityListeners() {
            const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
            events.forEach(event => {
                document.addEventListener(event, resetLogoutTimer, true);
            });
        }

        // Inizializzazione Supabase
        async function initSupabase() {
            console.log('Inizializzazione Supabase...');
            
            // Aspetta che Supabase sia caricato
            let attempts = 0;
            while (!window.supabase && attempts < 50) {
                await new Promise(r => setTimeout(r, 100));
                attempts++;
            }
            
            if (!window.supabase) {
                throw new Error('Supabase non caricato');
            }
            
            console.log('‚úÖ Supabase libreria caricata');
            
            // Crea client
            const url = 'https://hvviecqurdbpxxfmaapb.supabase.co';
            const key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh2dmllY3F1cmRicHh4Zm1hYXBiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIxMzMzMTEsImV4cCI6MjA2NzcwOTMxMX0.mGltlAbMzOSb6H2OVEDa4ukUpppEqqjtdKiSGKfjso4';
            
            supabaseClient = window.supabase.createClient(url, key, {
                auth: {
                    persistSession: true,
                    autoRefreshToken: false,  // Disabilita il refresh automatico
                    detectSessionInUrl: false
                }
            });
            console.log('‚úÖ Client Supabase creato con scadenza sessione');
            
            return supabaseClient;
        }

        // Funzioni per l'autenticazione
        async function login(email, password) {
            console.log('üîê Login per:', email);
            const { data, error } = await supabaseClient.auth.signInWithPassword({
                email: email.trim(),
                password: password
            });
            if (error) throw new Error(error.message);
            return data;
        }

        async function logout() {
            const { error } = await supabaseClient.auth.signOut();
            if (error) throw new Error(error.message);
        }

        async function getCurrentUser() {
            const { data: { user } } = await supabaseClient.auth.getUser();
            return user;
        }

        // Funzioni per i campionati
        async function createCompetition(name, type, season, groupsCount = null) {
            try {
                const competitionData = { name, type, season };
                
                // Aggiungi il numero di gironi per le coppe
                if (type === 'cup' && groupsCount) {
                    competitionData.groups_count = parseInt(groupsCount);
                }
                
                const { data, error } = await supabaseClient
                    .from('competitions')
                    .insert([competitionData])
                    .select();
                    
                if (error) throw new Error(error.message);
                return data[0];
            } catch (err) {
                throw new Error(err.message);
            }
        }

        async function getAllCompetitions() {
            // Prima proviamo con is_active, se fallisce proviamo senza
            let { data, error } = await supabaseClient
                .from('competitions')
                .select('*')
                .eq('is_active', true)
                .order('created_at', { ascending: false });
            
            // Se l'errore √® per la colonna is_active, prova senza filtro
            if (error && error.message.includes('is_active')) {
                const { data: allData, error: allError } = await supabaseClient
                    .from('competitions')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (allError) throw new Error(allError.message);
                return allData;
            }
            
            if (error) throw new Error(error.message);
            return data;
        }

        async function updateCompetition(id, updates) {
            const { data, error } = await supabaseClient
                .from('competitions')
                .update(updates)
                .eq('id', id)
                .select();
            if (error) throw new Error(error.message);
            return data[0];
        }

        async function deleteCompetition(id) {
            // Prima proviamo il soft delete, se fallisce eliminiamo fisicamente
            let { error } = await supabaseClient
                .from('competitions')
                .update({ is_active: false })
                .eq('id', id);
            
            // Se l'errore √® per la colonna is_active, elimina fisicamente
            if (error && error.message.includes('is_active')) {
                const { error: deleteError } = await supabaseClient
                    .from('competitions')
                    .delete()
                    .eq('id', id);
                
                if (deleteError) throw new Error(deleteError.message);
                return;
            }
            
            if (error) throw new Error(error.message);
        }

        // Funzioni per le squadre
        async function createTeam(name, competitionId) {
            const { data: teamData, error: teamError } = await supabaseClient
                .from('teams')
                .insert([{ name }])
                .select();
            if (teamError) throw new Error(teamError.message);
            
            if (competitionId) {
                await linkTeamToCompetition(teamData[0].id, competitionId);
            }
            
            return teamData[0];
        }

        async function linkTeamToCompetition(teamId, competitionId) {
            const { error } = await supabaseClient
                .from('team_competitions')
                .insert([{ team_id: teamId, competition_id: competitionId }]);
            if (error) throw new Error(error.message);
        }

        async function getTeamsByCompetition(competitionId) {
            const { data, error } = await supabaseClient
                .from('team_competitions')
                .select(`
                    teams (
                        id,
                        name,
                        created_at
                    )
                `)
                .eq('competition_id', competitionId);
            if (error) throw new Error(error.message);
            return data.map(item => item.teams);
        }

        async function removeTeamFromCompetition(teamId, competitionId) {
            const { error } = await supabaseClient
                .from('team_competitions')
                .delete()
                .eq('team_id', teamId)
                .eq('competition_id', competitionId);
            if (error) throw new Error(error.message);
        }

        // Funzioni per le giornate e partite
        async function createMatchday(competitionId, roundNumber, description = null) {
            const matchdayData = { 
                competition_id: competitionId, 
                round_number: roundNumber
            };
            
            // Aggiungi la descrizione se fornita
            if (description) {
                matchdayData.description = description;
            }
            
            const { data, error } = await supabaseClient
                .from('matchdays')
                .insert([matchdayData])
                .select();
            if (error) throw new Error(error.message);
            return data[0];
        }

        async function createMatch(matchdayId, homeTeamId, awayTeamId, groupLetter = null) {
            const matchData = { 
                matchday_id: matchdayId, 
                home_team_id: homeTeamId, 
                away_team_id: awayTeamId,
                status: 'scheduled'
            };
            
            // Aggiungi il girone se fornito
            if (groupLetter) {
                matchData.group_letter = groupLetter;
            }
            
            const { data, error } = await supabaseClient
                .from('matches')
                .insert([matchData])
                .select();
            if (error) throw new Error(error.message);
            return data[0];
        }

        async function updateMatchResult(matchId, homeScore, awayScore) {
            // Prima otteniamo i dati della partita per il competitionId
            const { data: matchData, error: matchError } = await supabaseClient
                .from('matches')
                .select(`
                    *,
                    matchdays(competition_id)
                `)
                .eq('id', matchId)
                .single();
            
            if (matchError) throw new Error(matchError.message);
            
            // Aggiorniamo il risultato
            const { data, error } = await supabaseClient
                .from('matches')
                .update({ 
                    home_score: homeScore, 
                    away_score: awayScore,
                    status: 'completed',
                    played_at: new Date().toISOString()
                })
                .eq('id', matchId)
                .select();
            
            if (error) throw new Error(error.message);
            
            // Aggiorniamo automaticamente la classifica
            const competitionId = matchData.matchdays.competition_id;
            await updateStandings(competitionId);
            
            return data[0];
        }

        // Funzione per controllare se esiste gi√† un calendario
        async function checkIfCalendarExists(competitionId) {
            const { data, error } = await supabaseClient
                .from('matchdays')
                .select('id')
                .eq('competition_id', competitionId)
                .limit(1);
            
            if (error) throw new Error(error.message);
            return data && data.length > 0;
        }

        async function getStandings(competitionId) {
            // Versione temporanea che calcola la classifica al volo
            // Finch√© non si eseguono le migrazioni del database
            try {
                const { data: standings, error } = await supabaseClient
                    .from('standings')
                    .select(`
                        *,
                        teams (name)
                    `)
                    .eq('competition_id', competitionId)
                    .order('points', { ascending: false })
                    .order('goal_difference', { ascending: false })
                    .order('goals_for', { ascending: false });
                
                if (error) {
                    console.log('Tabella standings non esistente, calcolo temporaneo dalla tabella teams');
                    // Fallback: calcola classifica vuota dalle squadre
                    const teams = await getTeamsByCompetition(competitionId);
                    return teams.map(team => ({
                        team_id: team.id,
                        competition_id: competitionId,
                        teams: { name: team.name },
                        games_played: 0,
                        wins: 0,
                        draws: 0,
                        losses: 0,
                        goals_for: 0,
                        goals_against: 0,
                        goal_difference: 0,
                        points: 0
                    }));
                }
                
                return standings;
            } catch (error) {
                console.error('Errore nel recupero della classifica:', error);
                // Fallback: calcola classifica vuota dalle squadre
                const teams = await getTeamsByCompetition(competitionId);
                return teams.map(team => ({
                    team_id: team.id,
                    competition_id: competitionId,
                    teams: { name: team.name },
                    games_played: 0,
                    wins: 0,
                    draws: 0,
                    losses: 0,
                    goals_for: 0,
                    goals_against: 0,
                    goal_difference: 0,
                    points: 0
                }));
            }
        }

        async function getMatchdaysByCompetition(competitionId) {
            try {
                const { data, error } = await supabaseClient
                    .from('matchdays')
                    .select(`
                        *,
                        matches (
                            id,
                            home_score,
                            away_score,
                            status,
                            played_at,
                            home_team:teams!matches_home_team_id_fkey (id, name),
                            away_team:teams!matches_away_team_id_fkey (id, name)
                        )
                    `)
                    .eq('competition_id', competitionId)
                    .order('round_number', { ascending: true });
                
                if (error) {
                    console.log('Tabelle matchdays/matches non esistenti, ritorno array vuoto');
                    return [];
                }
                
                return data;
            } catch (error) {
                console.error('Errore nel recupero del calendario:', error);
                return [];
            }
        }

        async function updateStandings(competitionId) {
            console.log('üîÑ Inizio ricalcolo classifica per competizione:', competitionId);
            
            // Prima resettiamo le statistiche
            const teams = await getTeamsByCompetition(competitionId);
            console.log('üë• Squadre trovate:', teams.length);
            
            // Inizializziamo le statistiche per tutte le squadre
            const teamStats = {};
            for (const team of teams) {
                teamStats[team.id] = {
                    team_id: team.id,
                    competition_id: competitionId,
                    games_played: 0,
                    wins: 0,
                    draws: 0,
                    losses: 0,
                    goals_for: 0,
                    goals_against: 0,
                    goal_difference: 0,
                    points: 0
                };
            }

            // Calcoliamo le statistiche dalle partite giocate
            const matchdays = await getMatchdaysByCompetition(competitionId);
            console.log('üìÖ Giornate trovate:', matchdays.length);
            
            let totalMatches = 0;
            let completedMatches = 0;
            
            for (const matchday of matchdays) {
                console.log(`üìÖ Giornata ${matchday.round_number}: ${matchday.matches.length} partite`);
                
                for (const match of matchday.matches) {
                    totalMatches++;
                    console.log(`‚öΩ Partita ${match.id}: ${match.home_team.name} vs ${match.away_team.name}, Status: ${match.status}, Risultato: ${match.home_score}-${match.away_score}`);
                    
                    if (match.status === 'completed') {
                        completedMatches++;
                        const homeScore = match.home_score || 0;
                        const awayScore = match.away_score || 0;
                        
                        console.log(`‚úÖ Partita completata: ${match.home_team.name} ${homeScore}-${awayScore} ${match.away_team.name}`);
                        
                        // Aggiorna statistiche squadra di casa
                        const homeStats = teamStats[match.home_team.id];
                        if (homeStats) {
                            homeStats.games_played++;
                            homeStats.goals_for += homeScore;
                            homeStats.goals_against += awayScore;
                            
                            if (homeScore > awayScore) {
                                homeStats.wins++;
                                homeStats.points += 3;
                                console.log(`üèÜ ${match.home_team.name} ha vinto (+3 punti)`);
                            } else if (homeScore === awayScore) {
                                homeStats.draws++;
                                homeStats.points += 1;
                                console.log(`ü§ù ${match.home_team.name} ha pareggiato (+1 punto)`);
                            } else {
                                homeStats.losses++;
                                console.log(`üíî ${match.home_team.name} ha perso (0 punti)`);
                            }
                        }
                        
                        // Aggiorna statistiche squadra ospite
                        const awayStats = teamStats[match.away_team.id];
                        if (awayStats) {
                            awayStats.games_played++;
                            awayStats.goals_for += awayScore;
                            awayStats.goals_against += homeScore;
                            
                            if (awayScore > homeScore) {
                                awayStats.wins++;
                                awayStats.points += 3;
                                console.log(`üèÜ ${match.away_team.name} ha vinto (+3 punti)`);
                            } else if (awayScore === homeScore) {
                                awayStats.draws++;
                                awayStats.points += 1;
                                console.log(`ü§ù ${match.away_team.name} ha pareggiato (+1 punto)`);
                            } else {
                                awayStats.losses++;
                                console.log(`üíî ${match.away_team.name} ha perso (0 punti)`);
                            }
                        }
                    }
                }
            }
            
            console.log(`üìä Totale partite: ${totalMatches}, Completate: ${completedMatches}`);
            
            // Prima eliminiamo tutti i record esistenti per questa competizione
            await supabaseClient
                .from('standings')
                .delete()
                .eq('competition_id', competitionId);
            
            // Poi inseriamo i nuovi record
            const standingsToInsert = [];
            for (const teamId in teamStats) {
                const stats = teamStats[teamId];
                stats.goal_difference = stats.goals_for - stats.goals_against;
                
                console.log(`üìã ${teams.find(t => t.id === teamId)?.name}: ${stats.games_played} partite, ${stats.wins}V ${stats.draws}N ${stats.losses}P, ${stats.goals_for}-${stats.goals_against}, ${stats.points} punti`);
                
                standingsToInsert.push(stats);
            }
            
            // Inserimento batch di tutti i record
            if (standingsToInsert.length > 0) {
                const { error } = await supabaseClient
                    .from('standings')
                    .insert(standingsToInsert);
                    
                if (error) {
                    console.error('‚ùå Errore nell\'inserimento:', error);
                    throw error;
                }
            }
            
            console.log('‚úÖ Ricalcolo classifica completato');
        }

        // Funzione per generare calendario all'italiana (andata e ritorno)
        function generateRoundRobinSchedule(teams) {
            const schedule = [];
            const teamsCopy = [...teams];
            
            // Se il numero di squadre √® dispari, aggiungi una squadra "riposo"
            if (teamsCopy.length % 2 === 1) {
                teamsCopy.push({ id: 'bye', name: 'Riposo' });
            }
            
            const numTeams = teamsCopy.length;
            const numRounds = numTeams - 1;
            
            // ANDATA
            for (let round = 0; round < numRounds; round++) {
                const roundMatches = [];
                
                for (let i = 0; i < numTeams / 2; i++) {
                    const home = teamsCopy[i];
                    const away = teamsCopy[numTeams - 1 - i];
                    
                    // Salta le partite con "riposo"
                    if (home.id !== 'bye' && away.id !== 'bye') {
                        roundMatches.push({
                            home_team: home,
                            away_team: away,
                            round_type: 'andata'
                        });
                    }
                }
                
                schedule.push({
                    round: round + 1,
                    matches: roundMatches,
                    phase: 'Andata'
                });
                
                // Ruota le squadre (tranne la prima)
                const temp = teamsCopy[1];
                for (let i = 1; i < numTeams - 1; i++) {
                    teamsCopy[i] = teamsCopy[i + 1];
                }
                teamsCopy[numTeams - 1] = temp;
            }
            
            // RITORNO (inverte casa/trasferta)
            for (let round = 0; round < numRounds; round++) {
                const roundMatches = [];
                
                for (let i = 0; i < numTeams / 2; i++) {
                    const away = teamsCopy[i];  // Inverte ruoli
                    const home = teamsCopy[numTeams - 1 - i];  // Inverte ruoli
                    
                    // Salta le partite con "riposo"
                    if (home.id !== 'bye' && away.id !== 'bye') {
                        roundMatches.push({
                            home_team: home,
                            away_team: away,
                            round_type: 'ritorno'
                        });
                    }
                }
                
                schedule.push({
                    round: numRounds + round + 1,
                    matches: roundMatches,
                    phase: 'Ritorno'
                });
                
                // Ruota le squadre (tranne la prima)
                const temp = teamsCopy[1];
                for (let i = 1; i < numTeams - 1; i++) {
                    teamsCopy[i] = teamsCopy[i + 1];
                }
                teamsCopy[numTeams - 1] = temp;
            }
            
            return schedule;
        }

        // Funzione per generare calendario a girone unico (solo andata) per la coppa
        function generateSingleRoundSchedule(teams) {
            const schedule = [];
            const teamsCopy = [...teams];
            
            // Se il numero di squadre √® dispari, aggiungi una squadra "riposo"
            if (teamsCopy.length % 2 === 1) {
                teamsCopy.push({ id: 'bye', name: 'Riposo' });
            }
            
            const numTeams = teamsCopy.length;
            const numRounds = numTeams - 1;
            
            // SOLO ANDATA
            for (let round = 0; round < numRounds; round++) {
                const roundMatches = [];
                
                for (let i = 0; i < numTeams / 2; i++) {
                    const home = teamsCopy[i];
                    const away = teamsCopy[numTeams - 1 - i];
                    
                    // Salta le partite con "riposo"
                    if (home.id !== 'bye' && away.id !== 'bye') {
                        roundMatches.push({
                            home_team: home,
                            away_team: away,
                            round_type: 'girone'
                        });
                    }
                }
                
                schedule.push({
                    round: round + 1,
                    matches: roundMatches,
                    phase: 'Girone'
                });
                
                // Ruota le squadre (tranne la prima)
                const temp = teamsCopy[1];
                for (let i = 1; i < numTeams - 1; i++) {
                    teamsCopy[i] = teamsCopy[i + 1];
                }
                teamsCopy[numTeams - 1] = temp;
            }
            
            return schedule;
        }

        // Funzione per generare calendario coppa (gironi + eliminazione)
        async function generateCupCalendar(competitionId, teams, groupsCount) {
            console.log(`üèÜ INIZIO generateCupCalendar:`, {
                competitionId,
                teamsCount: teams.length,
                groupsCount
            });
            
            if (teams.length < 4) {
                throw new Error('Servono almeno 4 squadre per un torneo coppa');
            }

            // Dividi le squadre nei gironi
            const groups = distributeTeamsInGroups(teams, groupsCount);
            
            // Genera calendari per ogni girone utilizzando il calendario a girone unico (solo andata)
            const groupSchedules = groups.map(groupTeams => generateSingleRoundSchedule(groupTeams));
            
            // Trova il numero massimo di giornate tra tutti i gironi
            const maxRounds = Math.max(...groupSchedules.map(schedule => schedule.length));
            
            let roundNumber = 1;
            
            // FASE GIRONI - Crea giornate unificate per tutti i gironi
            for (let roundIndex = 0; roundIndex < maxRounds; roundIndex++) {
                const allMatches = [];
                let roundDescription = '';
                
                // Raccogli tutte le partite di questa giornata da tutti i gironi
                for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                    const groupSchedule = groupSchedules[groupIndex];
                    
                    if (roundIndex < groupSchedule.length) {
                        const round = groupSchedule[roundIndex];
                        const groupLetter = String.fromCharCode(65 + groupIndex); // A, B, C, D
                        
                        // Aggiungi informazioni sul girone a ogni partita
                        const groupMatches = round.matches.map(match => ({
                            ...match,
                            groupLetter: groupLetter,
                            groupIndex: groupIndex
                        }));
                        
                        allMatches.push(...groupMatches);
                        
                        // Costruisci la descrizione della giornata
                        if (roundDescription === '') {
                            roundDescription = `${round.phase} Giornata ${round.round}`;
                        }
                    }
                }
                
                // Crea la giornata unificata se ci sono partite
                if (allMatches.length > 0) {
                    const matchday = await createMatchday(competitionId, roundNumber, roundDescription);
                    
                    // Crea tutte le partite per questa giornata
                    for (const match of allMatches) {
                        await createMatch(matchday.id, match.home_team.id, match.away_team.id, match.groupLetter);
                    }
                    
                    roundNumber++;
                }
            }
            
            console.log(`üèÜ Fasi gironi completate, inizio creazione fasi eliminazione con roundNumber: ${roundNumber}`);
            // FASE ELIMINAZIONE - Crea struttura per le fasi finali
            await createEliminationPhases(competitionId, groupsCount, roundNumber);
            console.log(`üèÜ generateCupCalendar completata con successo`);
        }

        // Funzione per generare calendario eliminazione diretta
        async function generateEliminationCalendar(competitionId, teams) {
            const eliminationRounds = calculateEliminationRounds(teams.length);
            let roundNumber = 1;
            
            // Se il numero di squadre non √® una potenza di 2, crea turni preliminari
            if (!isPowerOfTwo(teams.length)) {
                const { preliminaryMatches, advancingTeams } = createPreliminaryRound(teams);
                
                if (preliminaryMatches.length > 0) {
                    const matchday = await createMatchday(competitionId, roundNumber, 'Turno Preliminare');
                    for (const match of preliminaryMatches) {
                        await createMatch(matchday.id, match.home_team.id, match.away_team.id);
                    }
                    roundNumber++;
                }
                
                teams = advancingTeams;
            }
            
            // Crea le fasi di eliminazione
            let currentTeams = teams.length;
            const phases = ['Finale', 'Semifinale', 'Quarti di finale', 'Ottavi di finale', 'Sedicesimi di finale'];
            
            while (currentTeams > 1) {
                const phaseName = getPhaseName(currentTeams, phases);
                const matchday = await createMatchday(competitionId, roundNumber, phaseName);
                
                // Le partite verranno create quando si qualificheranno le squadre
                // Per ora creiamo solo la struttura delle giornate
                
                currentTeams = Math.floor(currentTeams / 2);
                roundNumber++;
            }
        }

        // Funzioni di supporto per la coppa
        function distributeTeamsInGroups(teams, groupsCount) {
            const groups = Array.from({ length: groupsCount }, () => []);
            
            // Distribuisci le squadre in modo alternato nei gironi
            teams.forEach((team, index) => {
                const groupIndex = index % groupsCount;
                groups[groupIndex].push(team);
            });
            
            return groups;
        }

        async function createEliminationPhases(competitionId, groupsCount, startingRoundNumber) {
            try {
                console.log(`Creazione fasi eliminazione: competitionId=${competitionId}, groupsCount=${groupsCount}, startingRoundNumber=${startingRoundNumber}`);
                let roundNumber = startingRoundNumber;
                
                if (groupsCount === 2) {
                    console.log('Creazione fasi per 2 gironi: Finale + Finale 3¬∞ posto');
                    
                    // Con 2 gironi: Finale diretta (primi di ogni girone)
                    const finalMatchday = await createMatchday(competitionId, roundNumber, 'Finale');
                    console.log('Giornata "Finale" creata:', finalMatchday);
                    
                    // Eventuale finale 3¬∞ posto (secondi di ogni girone)
                    const thirdPlaceMatchday = await createMatchday(competitionId, roundNumber + 1, 'Finale 3¬∞ posto');
                    console.log('Giornata "Finale 3¬∞ posto" creata:', thirdPlaceMatchday);
                    
                } else if (groupsCount === 4) {
                    console.log('Creazione fasi per 4 gironi: Semifinali + Finale + Finale 3¬∞ posto');
                    
                    // Con 4 gironi: Semifinali + Finale
                    const semifinalMatchday = await createMatchday(competitionId, roundNumber, 'Semifinali');
                    console.log('Giornata "Semifinali" creata:', semifinalMatchday);
                    roundNumber++;
                    
                    const finalMatchday = await createMatchday(competitionId, roundNumber, 'Finale');
                    console.log('Giornata "Finale" creata:', finalMatchday);
                    roundNumber++;
                    
                    const thirdPlaceMatchday = await createMatchday(competitionId, roundNumber, 'Finale 3¬∞ posto');
                    console.log('Giornata "Finale 3¬∞ posto" creata:', thirdPlaceMatchday);
                }
                
                console.log('Tutte le fasi di eliminazione create con successo');
                
            } catch (error) {
                console.error('Errore nella creazione delle fasi di eliminazione:', error);
                throw error;
            }
        }

        function isPowerOfTwo(n) {
            return n > 0 && (n & (n - 1)) === 0;
        }

        function createPreliminaryRound(teams) {
            const targetSize = Math.pow(2, Math.floor(Math.log2(teams.length)));
            const teamsToEliminate = teams.length - targetSize;
            const preliminaryMatches = [];
            const advancingTeams = [];
            
            // Le prime squadre passano direttamente
            for (let i = 0; i < teams.length - (teamsToEliminate * 2); i++) {
                advancingTeams.push(teams[i]);
            }
            
            // Le rimanenti giocano i preliminari
            for (let i = teams.length - (teamsToEliminate * 2); i < teams.length; i += 2) {
                if (i + 1 < teams.length) {
                    preliminaryMatches.push({
                        home_team: teams[i],
                        away_team: teams[i + 1]
                    });
                }
            }
            
            return { preliminaryMatches, advancingTeams };
        }

        function calculateEliminationRounds(numTeams) {
            return Math.ceil(Math.log2(numTeams));
        }

        function getPhaseName(currentTeams, phases) {
            if (currentTeams === 2) return 'Finale';
            if (currentTeams === 4) return 'Semifinale';
            if (currentTeams === 8) return 'Quarti di finale';
            if (currentTeams === 16) return 'Ottavi di finale';
            if (currentTeams === 32) return 'Sedicesimi di finale';
            return `Fase a ${currentTeams}`;
        }

        // Funzioni per calcolare le qualificate dai gironi della coppa
        async function calculateGroupWinners(competitionId) {
            try {
                // Prima ottieni tutte le giornate della competizione (escluse fasi finali)
                const { data: matchdays, error: matchdaysError } = await supabaseClient
                    .from('matchdays')
                    .select('id, description')
                    .eq('competition_id', competitionId)
                    .not('description', 'in', '("Semifinali","Finale","Finale 3¬∞ posto")');

                if (matchdaysError) throw matchdaysError;
                
                if (!matchdays || matchdays.length === 0) {
                    throw new Error('Nessuna giornata trovata per questa competizione');
                }

                const matchdayIds = matchdays.map(md => md.id);

                // Ottieni tutte le partite dei gironi completate
                const { data: matches, error: matchesError } = await supabaseClient
                    .from('matches')
                    .select(`
                        *,
                        home_team:teams!matches_home_team_id_fkey(id, name),
                        away_team:teams!matches_away_team_id_fkey(id, name)
                    `)
                    .in('matchday_id', matchdayIds)
                    .not('home_score', 'is', null)
                    .not('away_score', 'is', null)
                    .not('group_letter', 'is', null);

                if (matchesError) throw matchesError;

                console.log(`Trovate ${matches.length} partite completate per la competizione ${competitionId}`);

                // Raggruppa per lettera del girone
                const groupMatches = {};
                matches.forEach(match => {
                    if (!groupMatches[match.group_letter]) {
                        groupMatches[match.group_letter] = [];
                    }
                    groupMatches[match.group_letter].push(match);
                });

                console.log('Gironi trovati:', Object.keys(groupMatches));

                // Calcola la classifica per ogni girone
                const groupWinners = {};
                const groupRunners = {};

                for (const [groupLetter, groupMatchesList] of Object.entries(groupMatches)) {
                    const standings = calculateGroupStandings(groupMatchesList);
                    console.log(`Classifica girone ${groupLetter}:`, standings.map(s => `${s.team.name} (${s.points} pt)`));
                    
                    if (standings.length > 0) {
                        groupWinners[groupLetter] = standings[0]; // Prima classificata
                        if (standings.length > 1) {
                            groupRunners[groupLetter] = standings[1]; // Seconda classificata
                        }
                    }
                }

                console.log('Vincitori dei gironi:', Object.fromEntries(
                    Object.entries(groupWinners).map(([key, value]) => [key, value.team.name])
                ));

                return { groupWinners, groupRunners };
            } catch (error) {
                console.error('Errore nel calcolare le vincitrici dei gironi:', error);
                throw error;
            }
        }

        function calculateGroupStandings(matches) {
            const teams = {};

            // Inizializza le statistiche per ogni squadra
            matches.forEach(match => {
                if (!teams[match.home_team.id]) {
                    teams[match.home_team.id] = {
                        team: match.home_team,
                        points: 0,
                        played: 0,
                        won: 0,
                        drawn: 0,
                        lost: 0,
                        goals_for: 0,
                        goals_against: 0,
                        goal_difference: 0
                    };
                }
                if (!teams[match.away_team.id]) {
                    teams[match.away_team.id] = {
                        team: match.away_team,
                        points: 0,
                        played: 0,
                        won: 0,
                        drawn: 0,
                        lost: 0,
                        goals_for: 0,
                        goals_against: 0,
                        goal_difference: 0
                    };
                }
            });

            // Calcola le statistiche
            matches.forEach(match => {
                const homeStats = teams[match.home_team.id];
                const awayStats = teams[match.away_team.id];

                homeStats.played++;
                awayStats.played++;
                homeStats.goals_for += match.home_score;
                homeStats.goals_against += match.away_score;
                awayStats.goals_for += match.away_score;
                awayStats.goals_against += match.home_score;

                if (match.home_score > match.away_score) {
                    // Vittoria casa
                    homeStats.won++;
                    homeStats.points += 3;
                    awayStats.lost++;
                } else if (match.home_score < match.away_score) {
                    // Vittoria trasferta
                    awayStats.won++;
                    awayStats.points += 3;
                    homeStats.lost++;
                } else {
                    // Pareggio
                    homeStats.drawn++;
                    awayStats.drawn++;
                    homeStats.points += 1;
                    awayStats.points += 1;
                }
            });

            // Calcola la differenza reti
            Object.values(teams).forEach(team => {
                team.goal_difference = team.goals_for - team.goals_against;
            });

            // Ordina per: punti (desc), differenza reti (desc), gol fatti (desc), casualit√†
            return Object.values(teams).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                if (b.goal_difference !== a.goal_difference) return b.goal_difference - a.goal_difference;
                if (b.goals_for !== a.goals_for) return b.goals_for - a.goals_for;
                // Spareggio casuale
                return Math.random() - 0.5;
            });
        }

        async function generateEliminationMatches(competitionId) {
            console.log('üî•üî•üî• CHIAMATA generateEliminationMatches - ID:', competitionId);
            try {
                // Ottieni informazioni sulla competizione
                const { data: competition, error: compError } = await supabaseClient
                    .from('competitions')
                    .select('groups_count, type')
                    .eq('id', competitionId)
                    .single();

                if (compError) throw compError;

                const groupsCount = competition.groups_count;
                console.log(`Generazione fasi eliminazione per competizione tipo ${competition.type} con ${groupsCount} gironi`);

                // Verifica che sia effettivamente una coppa
                if (competition.type !== 'cup') {
                    throw new Error('Questa funzione √® disponibile solo per le competizioni di tipo "coppa"');
                }

                // Verifica che le giornate delle fasi finali esistano
                const phasesCheck = await verifyEliminationPhasesExist(competitionId, groupsCount);
                
                if (!phasesCheck.exist) {
                    // Le fasi finali mancano, crea automaticamente
                    console.log('üîß Auto-riparazione: Fasi finali mancanti, creazione automatica...');
                    console.log('üîß Fasi mancanti:', phasesCheck.missingPhases);
                    
                    try {
                        // Calcola il prossimo round number
                        const { data: lastMatchday } = await supabaseClient
                            .from('matchdays')
                            .select('round_number')
                            .eq('competition_id', competitionId)
                            .order('round_number', { ascending: false })
                            .limit(1)
                            .single();
                            
                        const nextRoundNumber = lastMatchday ? lastMatchday.round_number + 1 : 1;
                        console.log('üîß Auto-riparazione: prossimo numero giornata:', nextRoundNumber);
                        
                        // Crea le fasi mancanti
                        await createEliminationPhases(competitionId, groupsCount, nextRoundNumber);
                        console.log('‚úÖ Auto-riparazione: Fasi finali create automaticamente!');
                        showSuccess('‚úÖ Fasi finali create automaticamente! Generazione partite in corso...');
                        
                    } catch (fixError) {
                        console.error('‚ùå Errore durante la riparazione automatica:', fixError);
                        showError('‚ùå Auto-riparazione fallita: ' + fixError.message);
                        throw new Error(`Impossibile creare le fasi finali: ${fixError.message}`);
                    }
                }

                // Verifica quale fase √® da generare
                const nextPhase = await determineNextPhase(competitionId, groupsCount);
                console.log(`Prossima fase da generare: ${nextPhase}`);

                switch (nextPhase) {
                    case 'semifinals':
                        const { groupWinners } = await calculateGroupWinners(competitionId);
                        if (groupsCount === 4) {
                            await createSemifinalMatches(competitionId, groupWinners);
                        }
                        break;
                    
                    case 'finals':
                        if (groupsCount === 2) {
                            // Con 2 gironi: genera finale direttamente dai gironi
                            const { groupWinners, groupRunners } = await calculateGroupWinners(competitionId);
                            await createFinalMatches(competitionId, groupWinners, groupRunners);
                        } else if (groupsCount === 4) {
                            // Con 4 gironi: genera finale dai risultati delle semifinali
                            await createFinalFromSemifinals(competitionId);
                        }
                        break;
                    
                    case 'third_place':
                        // Genera finale 3¬∞ posto dai perdenti delle semifinali
                        await createThirdPlaceFromSemifinals(competitionId);
                        break;
                    
                    case 'complete':
                        // Rigenera tutte le fasi finali: prima cancella quelle esistenti
                        await clearFinalPhases(competitionId);
                        
                        // CRUCIALE: Ricrea le fasi finali dopo averle cancellate
                        const { data: lastMatchday } = await supabaseClient
                            .from('matchdays')
                            .select('round_number')
                            .eq('competition_id', competitionId)
                            .order('round_number', { ascending: false })
                            .limit(1)
                            .single();
                            
                        const nextRoundNumber = lastMatchday ? lastMatchday.round_number + 1 : 1;
                        await createEliminationPhases(competitionId, groupsCount, nextRoundNumber);
                        console.log('‚úÖ Fasi finali ricreate dopo cancellazione');
                        
                        // Poi rigenera dalla prima fase necessaria
                        if (groupsCount === 2) {
                            // Con 2 gironi: genera solo finale
                            const { groupWinners, groupRunners } = await calculateGroupWinners(competitionId);
                            await createFinalMatches(competitionId, groupWinners, groupRunners);
                        } else if (groupsCount === 4) {
                            // Con 4 gironi: genera semifinali, poi finale, poi 3¬∞ posto
                            const { groupWinners } = await calculateGroupWinners(competitionId);
                            await createSemifinalMatches(competitionId, groupWinners);
                            showSuccess('Semifinali rigenerate! Completa i risultati delle semifinali per generare finale e finale 3¬∞ posto.');
                            return;
                        }
                        break;
                }

                showSuccess('Partite delle fasi finali generate con successo!');
            } catch (error) {
                console.error('Errore nella generazione delle partite finali:', error);
                showError('Errore nella generazione delle partite finali: ' + error.message);
            }
        }

        async function verifyEliminationPhasesExist(competitionId, groupsCount) {
            const { data: matchdays, error } = await supabaseClient
                .from('matchdays')
                .select('description, round_number')
                .eq('competition_id', competitionId);

            if (error) throw error;

            console.log('üîç DEBUG - Tutte le giornate trovate per la competizione:', matchdays);
            
            const existingPhases = matchdays.map(md => md.description);
            console.log('üîç Fasi esistenti (descrizioni):', existingPhases);

            // Controlla se le fasi finali necessarie esistono
            const requiredPhases = [];
            if (groupsCount === 2) {
                requiredPhases.push('Finale');
            } else if (groupsCount === 4) {
                requiredPhases.push('Semifinali', 'Finale');
            }

            console.log('üîç Fasi richieste:', requiredPhases);
            const missingPhases = requiredPhases.filter(phase => !existingPhases.includes(phase));
            console.log('üîç Fasi mancanti:', missingPhases);
            
            if (missingPhases.length > 0) {
                console.error('‚ùå Fasi mancanti trovate:', missingPhases);
                
                // Mostra anche informazioni sulla competizione per debug
                const { data: compInfo } = await supabaseClient
                    .from('competitions')
                    .select('name, type, groups_count')
                    .eq('id', competitionId)
                    .single();
                
                console.log('üîç Informazioni competizione:', compInfo);
                
                return {
                    exist: false,
                    missingPhases: missingPhases,
                    competitionInfo: compInfo,
                    debugInfo: {
                        totalMatchdays: matchdays.length,
                        matchdaysWithDescription: matchdays.filter(md => md.description).length,
                        existingPhases: existingPhases,
                        requiredPhases: requiredPhases
                    }
                };
            }

            console.log('‚úÖ Tutte le fasi necessarie sono presenti');
            return {
                exist: true,
                existingPhases: existingPhases,
                requiredPhases: requiredPhases
            };
        }

        async function clearFinalPhases(competitionId) {
            try {
                // Ottieni le giornate delle fasi finali
                const { data: finalMatchdays, error: matchdaysError } = await supabaseClient
                    .from('matchdays')
                    .select('id')
                    .eq('competition_id', competitionId)
                    .in('description', ['Semifinali', 'Finale', 'Finale 3¬∞ posto']);

                if (matchdaysError) throw matchdaysError;

                if (finalMatchdays && finalMatchdays.length > 0) {
                    const matchdayIds = finalMatchdays.map(md => md.id);
                    
                    // Cancella prima le partite di queste giornate
                    const { error: matchesError } = await supabaseClient
                        .from('matches')
                        .delete()
                        .in('matchday_id', matchdayIds);

                    if (matchesError) throw matchesError;

                    // Poi cancella le giornate stesse
                    const { error: deletionError } = await supabaseClient
                        .from('matchdays')
                        .delete()
                        .in('id', matchdayIds);

                    if (deletionError) throw deletionError;
                }

                // Pulisci il localStorage dai dati delle semifinali se esistono
                localStorage.removeItem(`semifinalLosers_${competitionId}`);
                
            } catch (error) {
                console.error('Errore nella cancellazione delle fasi finali:', error);
                throw error;
            }
        }

        async function determineNextPhase(competitionId, groupsCount) {
            // Verifica quali giornate esistono gi√†
            const { data: matchdays, error } = await supabaseClient
                .from('matchdays')
                .select('description')
                .eq('competition_id', competitionId)
                .in('description', ['Semifinali', 'Finale', 'Finale 3¬∞ posto']);

            if (error) throw error;

            const existingPhases = matchdays.map(md => md.description);

            if (groupsCount === 2) {
                // Con 2 gironi: solo finale diretta
                if (!existingPhases.includes('Finale')) {
                    return 'finals';
                } else {
                    return 'complete';
                }
            } else if (groupsCount === 4) {
                // Con 4 gironi: semifinali ‚Üí finale ‚Üí 3¬∞ posto
                if (!existingPhases.includes('Semifinali')) {
                    return 'semifinals';
                } else if (!existingPhases.includes('Finale')) {
                    // Verifica se le semifinali sono completate
                    const semifinalsComplete = await checkSemifinalsComplete(competitionId);
                    if (semifinalsComplete) {
                        return 'finals';
                    } else {
                        showError('Le semifinali devono essere completate prima di generare la finale');
                        throw new Error('Semifinali non completate');
                    }
                } else if (!existingPhases.includes('Finale 3¬∞ posto')) {
                    return 'third_place';
                } else {
                    return 'complete';
                }
            }

            return 'complete';
        }

        async function checkSemifinalsComplete(competitionId) {
            const { data: semifinalMatchday } = await supabaseClient
                .from('matchdays')
                .select('id')
                .eq('competition_id', competitionId)
                .eq('description', 'Semifinali')
                .single();

            if (!semifinalMatchday) return false;

            const { data: matches } = await supabaseClient
                .from('matches')
                .select('home_score, away_score')
                .eq('matchday_id', semifinalMatchday.id);

            // Tutte le partite devono avere un risultato
            return matches && matches.every(match => 
                match.home_score !== null && match.away_score !== null
            );
        }

        async function updateFinalsButtonText(competitionId, groupsCount) {
            const finalsBtn = document.getElementById('generate-finals');
            const repairBtn = document.getElementById('repair-finals');
            
            try {
                // Verifica se esistono le fasi di eliminazione
                const phasesExist = await verifyEliminationPhasesExist(competitionId, groupsCount);
                
                if (!phasesExist.exist) {
                    // Mostra il pulsante di riparazione se le fasi mancano
                    repairBtn.style.display = 'block';
                    finalsBtn.style.display = 'none';
                    return;
                }
                
                // Nascondi il pulsante di riparazione se le fasi esistono
                repairBtn.style.display = 'none';
                finalsBtn.style.display = 'block';
                
                // Determina quale fase generare e aggiorna il testo del pulsante
                const nextPhase = await determineNextPhase(competitionId, groupsCount);
                switch (nextPhase) {
                    case 'semifinals':
                        finalsBtn.textContent = 'Genera Semifinali';
                        finalsBtn.disabled = false;
                        finalsBtn.className = 'bg-blue-600 text-white px-4 py-2 rounded font-semibold hover:bg-blue-700';
                        break;
                    case 'finals':
                        finalsBtn.textContent = 'Genera Finale';
                        finalsBtn.disabled = false;
                        finalsBtn.className = 'bg-purple-600 text-white px-4 py-2 rounded font-semibold hover:bg-purple-700';
                        break;
                    case 'third_place':
                        finalsBtn.textContent = 'Genera Finale 3¬∞ posto';
                        finalsBtn.disabled = false;
                        finalsBtn.className = 'bg-green-600 text-white px-4 py-2 rounded font-semibold hover:bg-green-700';
                        break;
                    case 'complete':
                        finalsBtn.textContent = 'Rigenera Fasi Finali';
                        finalsBtn.disabled = false;
                        finalsBtn.className = 'bg-orange-600 text-white px-4 py-2 rounded font-semibold hover:bg-orange-700';
                        break;
                    default:
                        finalsBtn.textContent = 'Genera Fasi Finali';
                        finalsBtn.disabled = false;
                        finalsBtn.className = 'bg-blue-600 text-white px-4 py-2 rounded font-semibold hover:bg-blue-700';
                }
            } catch (error) {
                console.error('Errore nell\'aggiornamento del pulsante finali:', error);
                // In caso di errore, lascia il pulsante in stato normale
                finalsBtn.textContent = 'Genera Fasi Finali';
                finalsBtn.disabled = false;
                finalsBtn.className = 'bg-blue-600 text-white px-4 py-2 rounded font-semibold hover:bg-blue-700';
                repairBtn.style.display = 'none';
            }
        }

        async function createFinalMatches(competitionId, groupWinners, groupRunners) {
            try {
                console.log('Inizio creazione finali per competizione:', competitionId);
                console.log('üîç DEBUG - Tipo di competitionId:', typeof competitionId, competitionId);
                
                // Prima verifichiamo che le giornate delle finali esistano
                const { data: existingMatchdays, error: checkError } = await supabaseClient
                    .from('matchdays')
                    .select('id, description, competition_id')
                    .eq('competition_id', competitionId)
                    .in('description', ['Finale', 'Finale 3¬∞ posto']);

                if (checkError) {
                    console.error('Errore nel verificare le giornate esistenti:', checkError);
                    throw new Error('Errore nel verificare le giornate delle finali');
                }

                console.log('Giornate finali esistenti:', existingMatchdays);
                
                // Se non trova giornate finali, cerca TUTTE le giornate per debug
                if (existingMatchdays.length === 0) {
                    console.log('üö® NESSUNA GIORNATA FINALE TROVATA! Cerco tutte le giornate...');
                    
                    const { data: allMatchdays } = await supabaseClient
                        .from('matchdays')
                        .select('*')
                        .eq('competition_id', competitionId);
                    console.log('üîç Tutte le giornate per questa competizione:', allMatchdays);
                    
                    // Cerca anche tutte le giornate con "Finale" nel nome
                    const { data: finaleMatchdays } = await supabaseClient
                        .from('matchdays')
                        .select('*')
                        .ilike('description', '%finale%');
                    console.log('üîç Tutte le giornate contenenti "finale":', finaleMatchdays);
                    
                    throw new Error(`Nessuna giornata finale trovata per questa competizione. 
                    
üîç DEBUG INFO:
- Competition ID: ${competitionId}
- Giornate totali trovate: ${allMatchdays?.length || 0}
- Giornate finali in tutto il DB: ${finaleMatchdays?.length || 0}

üí° POSSIBILE CAUSA: Le giornate finali non sono state create o sono associate a un'altra competizione.
                    
üîß SOLUZIONE: Usa il pulsante di riparazione per creare le giornate mancanti.`);
                }

                // Finale: A vs B (primi di ogni girone)
                if (groupWinners['A'] && groupWinners['B']) {
                    const { data: finalMatchday, error: finalError } = await supabaseClient
                        .from('matchdays')
                        .select('id')
                        .eq('competition_id', competitionId)
                        .eq('description', 'Finale')
                        .single();

                    if (finalError) {
                        console.error('Errore nel trovare la giornata della finale:', finalError);
                        console.log('Dettagli errore finale:', finalError);
                        
                        // Prova a vedere tutte le giornate della competizione
                        const { data: allMatchdays } = await supabaseClient
                            .from('matchdays')
                            .select('*')
                            .eq('competition_id', competitionId);
                        console.log('Tutte le giornate della competizione:', allMatchdays);
                        
                        throw new Error('Giornata della finale non trovata. Le giornate delle fasi finali potrebbero non essere state create correttamente durante la generazione del calendario.');
                    }

                    if (finalMatchday) {
                        await createMatch(finalMatchday.id, groupWinners['A'].team.id, groupWinners['B'].team.id);
                        console.log(`Finale creata: ${groupWinners['A'].team.name} vs ${groupWinners['B'].team.name}`);
                    }
                } else {
                    const missingGroups = [];
                    if (!groupWinners['A']) missingGroups.push('A');
                    if (!groupWinners['B']) missingGroups.push('B');
                    throw new Error(`Vincitori mancanti per i gironi: ${missingGroups.join(', ')}. Completa prima tutti i gironi.`);
                }

                // Finale 3¬∞ posto: 2¬∞A vs 2¬∞B (se esistono)
                if (groupRunners['A'] && groupRunners['B']) {
                    const { data: thirdPlaceMatchday, error: thirdError } = await supabaseClient
                        .from('matchdays')
                        .select('id')
                        .eq('competition_id', competitionId)
                        .eq('description', 'Finale 3¬∞ posto')
                        .single();

                    if (thirdError) {
                        console.warn('Giornata finale 3¬∞ posto non trovata (normale se non prevista):', thirdError);
                    } else if (thirdPlaceMatchday) {
                        await createMatch(thirdPlaceMatchday.id, groupRunners['A'].team.id, groupRunners['B'].team.id);
                        console.log(`Finale 3¬∞ posto creata: ${groupRunners['A'].team.name} vs ${groupRunners['B'].team.name}`);
                    }
                }

                showSuccess('Finale generate con successo!');
                
            } catch (error) {
                console.error('Errore nella creazione delle finali:', error);
                throw error;
            }
        }

        async function createSemifinalMatches(competitionId, groupWinners) {
            try {
                // Semifinali: A vs D, B vs C
                const { data: semifinalMatchday, error: matchdayError } = await supabaseClient
                    .from('matchdays')
                    .select('id')
                    .eq('competition_id', competitionId)
                    .eq('description', 'Semifinali')
                    .single();

                if (matchdayError) {
                    console.error('Errore nel trovare la giornata delle semifinali:', matchdayError);
                    throw new Error('Giornata delle semifinali non trovata. Assicurati che il calendario sia stato generato correttamente.');
                }

                if (!semifinalMatchday) {
                    throw new Error('Giornata delle semifinali non trovata');
                }

                // Verifica che tutti i vincitori dei gironi esistano
                const requiredGroups = ['A', 'B', 'C', 'D'];
                const missingGroups = requiredGroups.filter(group => !groupWinners[group]);
                
                if (missingGroups.length > 0) {
                    throw new Error(`Vincitori mancanti per i gironi: ${missingGroups.join(', ')}. Completa prima tutti i gironi.`);
                }

                console.log('Creazione semifinali:', {
                    matchdayId: semifinalMatchday.id,
                    semifinal1: `${groupWinners['A'].team.name} vs ${groupWinners['D'].team.name}`,
                    semifinal2: `${groupWinners['B'].team.name} vs ${groupWinners['C'].team.name}`
                });

                // Crea le partite delle semifinali: A vs D, B vs C
                await createMatch(semifinalMatchday.id, groupWinners['A'].team.id, groupWinners['D'].team.id);
                await createMatch(semifinalMatchday.id, groupWinners['B'].team.id, groupWinners['C'].team.id);

                showSuccess('Semifinali generate con successo!');
                
            } catch (error) {
                console.error('Errore nella creazione delle semifinali:', error);
                throw error;
            }
        }

        async function createFinalFromSemifinals(competitionId) {
            // Ottieni i risultati delle semifinali
            const { data: semifinalMatchday } = await supabaseClient
                .from('matchdays')
                .select('id')
                .eq('competition_id', competitionId)
                .eq('description', 'Semifinali')
                .single();

            if (!semifinalMatchday) {
                throw new Error('Semifinali non trovate');
            }

            const { data: semifinalMatches } = await supabaseClient
                .from('matches')
                .select(`
                    *,
                    home_team:teams!matches_home_team_id_fkey(id, name),
                    away_team:teams!matches_away_team_id_fkey(id, name)
                `)
                .eq('matchday_id', semifinalMatchday.id);

            if (!semifinalMatches || semifinalMatches.length !== 2) {
                throw new Error('Semifinali non complete o non trovate');
            }

            // Determina i vincitori delle semifinali
            const winners = [];
            const losers = [];

            semifinalMatches.forEach(match => {
                if (match.home_score > match.away_score) {
                    winners.push(match.home_team);
                    losers.push(match.away_team);
                } else if (match.away_score > match.home_score) {
                    winners.push(match.away_team);
                    losers.push(match.home_team);
                } else {
                    throw new Error(`Partita semifinale ${match.home_team.name} vs ${match.away_team.name} √® finita in pareggio. Risolvere il pareggio prima di procedere.`);
                }
            });

            // Crea la finale
            const { data: finalMatchday } = await supabaseClient
                .from('matchdays')
                .select('id')
                .eq('competition_id', competitionId)
                .eq('description', 'Finale')
                .single();

            if (finalMatchday && winners.length === 2) {
                await createMatch(finalMatchday.id, winners[0].id, winners[1].id);
            }

            // Salva i perdenti per la finale 3¬∞ posto
            await saveLosersForThirdPlace(competitionId, losers);
        }

        async function createThirdPlaceFromSemifinals(competitionId) {
            // Recupera i perdenti delle semifinali
            const losers = await getLosersFromSemifinals(competitionId);

            if (losers.length === 2) {
                const { data: thirdPlaceMatchday } = await supabaseClient
                    .from('matchdays')
                    .select('id')
                    .eq('competition_id', competitionId)
                    .eq('description', 'Finale 3¬∞ posto')
                    .single();

                if (thirdPlaceMatchday) {
                    await createMatch(thirdPlaceMatchday.id, losers[0].id, losers[1].id);
                }
            }
        }

        async function saveLosersForThirdPlace(competitionId, losers) {
            // Salva temporaneamente i perdenti in una tabella di supporto o in localStorage
            // Per semplicit√†, uso localStorage
            localStorage.setItem(`losers_${competitionId}`, JSON.stringify(losers));
        }

        async function getLosersFromSemifinals(competitionId) {
            // Recupera i perdenti dal localStorage o ricalcola dalle semifinali
            const stored = localStorage.getItem(`losers_${competitionId}`);
            if (stored) {
                return JSON.parse(stored);
            }

            // Se non sono salvati, ricalcola dalle semifinali
            const { data: semifinalMatchday } = await supabaseClient
                .from('matchdays')
                .select('id')
                .eq('competition_id', competitionId)
                .eq('description', 'Semifinali')
                .single();

            if (!semifinalMatchday) return [];

            const { data: semifinalMatches } = await supabaseClient
                .from('matches')
                .select(`
                    *,
                    home_team:teams!matches_home_team_id_fkey(id, name),
                    away_team:teams!matches_away_team_id_fkey(id, name)
                `)
                .eq('matchday_id', semifinalMatchday.id);

            const losers = [];
            semifinalMatches.forEach(match => {
                if (match.home_score > match.away_score) {
                    losers.push(match.away_team);
                } else if (match.away_score > match.home_score) {
                    losers.push(match.home_team);
                }
            });

            return losers;
        }

        // Funzioni UI
        function showError(message) {
            const authMessage = document.getElementById('auth-message');
            authMessage.textContent = message;
            authMessage.className = 'text-sm mt-2 text-red-400';
        }

        function showSuccess(message) {
            const authMessage = document.getElementById('auth-message');
            authMessage.textContent = message;
            authMessage.className = 'text-sm mt-2 text-green-300';
        }

        function getTypeLabel(type) {
            const labels = {
                'all-against-all': 'Campionato all\'italiana',
                'elimination': 'Eliminazione diretta',
                'cup': 'Coppa (Gironi + Finale)'
            };
            return labels[type] || type;
        }

        // Funzioni per la sezione pubblica
        function showPublicTab(tabName) {
            // Nascondi tutti i tab content pubblici
            document.querySelectorAll('#public-section .tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Rimuovi active class da tutti i tab button pubblici
            document.querySelectorAll('#public-section .tab-button').forEach(button => {
                button.classList.remove('border-yellow-400', 'font-semibold', 'text-yellow-400');
                button.classList.add('text-gray-300');
            });
            
            // Mostra il tab selezionato
            document.getElementById('public-' + tabName + '-tab').classList.remove('hidden');
            
            // Attiva il tab button
            const activeButton = document.getElementById('public-tab-' + tabName);
            activeButton.classList.add('border-yellow-400', 'font-semibold', 'text-yellow-400');
            activeButton.classList.remove('text-gray-300');
        }

        async function loadPublicCompetitions() {
            try {
                const competitions = await getAllCompetitions();
                const publicSelect = document.getElementById('public-competition-select');
                
                const optionsHTML = competitions.map(comp => 
                    `<option value="${comp.id}">${comp.name} (${getTypeLabel(comp.type)})</option>`
                ).join('');
                
                publicSelect.innerHTML = '<option value="">Seleziona un campionato per visualizzare classifica e calendario...</option>' + optionsHTML;
                
            } catch (error) {
                console.error('Errore nel caricamento dei campionati pubblici:', error);
            }
        }

        async function loadPublicStandings(competitionId) {
            try {
                // Prima ottieni i dettagli della competizione per determinare il tipo
                const { data: competition, error: compError } = await supabaseClient
                    .from('competitions')
                    .select('type, groups_count')
                    .eq('id', competitionId)
                    .single();
                
                if (compError) throw compError;
                
                const standingsContent = document.getElementById('public-standings-content');
                
                // Se √® una coppa, mostra le fasi di eliminazione con evidenza
                if (competition.type === 'cup') {
                    await loadCupEliminationStandings(competitionId, competition.groups_count, standingsContent);
                } else {
                    // Classifica normale per le leghe
                    const standings = await getStandings(competitionId);
                    
                    if (standings.length === 0) {
                        standingsContent.innerHTML = '<p class="text-gray-400 italic">Nessuna classifica disponibile</p>';
                        return;
                    }

                    const standingsHTML = `
                        <div class="overflow-x-auto">
                            <table class="w-full table-auto standings-table">
                                <thead>
                                    <tr class="border-b border-yellow-400">
                                        <th class="text-left py-2 px-3">Pos</th>
                                        <th class="text-left py-2 px-3">Squadra</th>
                                        <th class="text-center py-2 px-3">G</th>
                                        <th class="text-center py-2 px-3">V</th>
                                        <th class="text-center py-2 px-3">N</th>
                                        <th class="text-center py-2 px-3">P</th>
                                        <th class="text-center py-2 px-3">GF</th>
                                        <th class="text-center py-2 px-3">GS</th>
                                        <th class="text-center py-2 px-3">DR</th>
                                        <th class="text-center py-2 px-3 font-bold">Pt</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${standings.map((team, index) => {
                                        let positionClass = '';
                                        if (index === 0) positionClass = 'bg-yellow-500 bg-opacity-20'; // Primo posto
                                        else if (index === 1 || index === 2) positionClass = 'bg-green-500 bg-opacity-20'; // Secondo e terzo
                                        else if (index >= standings.length - 3) positionClass = 'bg-red-500 bg-opacity-20'; // Zona retrocessione
                                        
                                        return `
                                            <tr class="border-b border-green-700 hover:bg-green-700 ${positionClass}">
                                                <td class="py-2 px-3 font-bold">${index + 1}</td>
                                                <td class="py-2 px-3 font-semibold">${team.teams.name}</td>
                                                <td class="text-center py-2 px-3">${team.games_played}</td>
                                                <td class="text-center py-2 px-3">${team.wins}</td>
                                                <td class="text-center py-2 px-3">${team.draws}</td>
                                                <td class="text-center py-2 px-3">${team.losses}</td>
                                                <td class="text-center py-2 px-3">${team.goals_for}</td>
                                                <td class="text-center py-2 px-3">${team.goals_against}</td>
                                                <td class="text-center py-2 px-3">${team.goal_difference > 0 ? '+' : ''}${team.goal_difference}</td>
                                                <td class="text-center py-2 px-3 font-bold text-yellow-400">${team.points}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="mt-4 text-xs text-gray-400">
                            <div class="flex flex-wrap gap-4">
                                <span class="flex items-center"><span class="w-3 h-3 bg-yellow-500 bg-opacity-20 rounded mr-1"></span>1¬∞ posto</span>
                                <span class="flex items-center"><span class="w-3 h-3 bg-green-500 bg-opacity-20 rounded mr-1"></span>2¬∞-3¬∞ posto</span>
                                <span class="flex items-center"><span class="w-3 h-3 bg-red-500 bg-opacity-20 rounded mr-1"></span>Zona retrocessione</span>
                            </div>
                        </div>
                    `;

                    standingsContent.innerHTML = standingsHTML;
                }
                
            } catch (error) {
                console.error('Errore nel caricamento della classifica pubblica:', error);
                document.getElementById('public-standings-content').innerHTML = '<p class="text-red-400">Errore nel caricamento della classifica</p>';
            }
        }

        async function loadCupEliminationStandings(competitionId, groupsCount, standingsContent) {
            try {
                // Ottieni le partite delle fasi di eliminazione
                const { data: eliminationMatchdays, error: elimError } = await supabaseClient
                    .from('matchdays')
                    .select(`
                        *,
                        matches (
                            id,
                            home_score,
                            away_score,
                            status,
                            home_team:teams!matches_home_team_id_fkey (id, name),
                            away_team:teams!matches_away_team_id_fkey (id, name)
                        )
                    `)
                    .eq('competition_id', competitionId)
                    .in('description', ['Semifinali', 'Semifinale', 'Finale', 'Finale 3¬∞ posto'])
                    .order('round_number', { ascending: true });

                if (elimError) throw elimError;

                let eliminationHTML = '';
                
                // Se ci sono fasi di eliminazione, mostrali con evidenza
                if (eliminationMatchdays && eliminationMatchdays.length > 0) {
                    eliminationHTML = `
                        <div class="bg-gradient-to-r from-yellow-500 to-red-500 p-6 rounded-lg shadow-lg mb-6">
                            <h3 class="text-2xl font-bold text-white mb-4 text-center">üèÜ FASI FINALI</h3>
                            <div class="space-y-4">
                                ${eliminationMatchdays.map(matchday => {
                                    const hasMatches = matchday.matches && matchday.matches.length > 0;
                                    
                                    return `
                                        <div class="bg-white bg-opacity-20 backdrop-blur rounded-lg p-4">
                                            <h4 class="text-lg font-bold text-white mb-3 text-center">
                                                ${matchday.description}
                                            </h4>
                                            ${hasMatches ? `
                                                <div class="space-y-2">
                                                    ${matchday.matches.map(match => {
                                                        if (match.status === 'completed') {
                                                            const homeWon = (match.home_score || 0) > (match.away_score || 0);
                                                            const awayWon = (match.away_score || 0) > (match.home_score || 0);
                                                            const isDraw = (match.home_score || 0) === (match.away_score || 0);
                                                            
                                                            return `
                                                                <div class="flex items-center justify-between p-3 bg-white bg-opacity-30 rounded">
                                                                    <div class="flex items-center space-x-4">
                                                                        <span class="font-bold ${homeWon ? 'text-yellow-200' : 'text-white'}">${match.home_team.name}</span>
                                                                        <span class="text-white font-bold text-lg">${match.home_score || 0} - ${match.away_score || 0}</span>
                                                                        <span class="font-bold ${awayWon ? 'text-yellow-200' : 'text-white'}">${match.away_team.name}</span>
                                                                    </div>
                                                                    ${!isDraw ? `
                                                                        <div class="text-right">
                                                                            <span class="bg-yellow-400 text-black px-2 py-1 rounded font-bold text-sm">
                                                                                üèÜ ${homeWon ? match.home_team.name : match.away_team.name}
                                                                            </span>
                                                                        </div>
                                                                    ` : `
                                                                        <div class="text-right">
                                                                            <span class="bg-gray-400 text-white px-2 py-1 rounded font-bold text-sm">
                                                                                PAREGGIO
                                                                            </span>
                                                                        </div>
                                                                    `}
                                                                </div>
                                                            `;
                                                        } else {
                                                            return `
                                                                <div class="flex items-center justify-between p-3 bg-white bg-opacity-20 rounded">
                                                                    <div class="flex items-center space-x-4">
                                                                        <span class="font-medium text-white">${match.home_team.name}</span>
                                                                        <span class="text-gray-300">vs</span>
                                                                        <span class="font-medium text-white">${match.away_team.name}</span>
                                                                    </div>
                                                                    <span class="text-gray-300 text-sm">Da giocare</span>
                                                                </div>
                                                            `;
                                                        }
                                                    }).join('')}
                                                </div>
                                            ` : `
                                                <div class="text-center py-4 text-white">
                                                    <p class="italic">Partite non ancora generate</p>
                                                </div>
                                            `}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Aggiungi le classifiche dei gironi sotto (meno evidenti)
                const standings = await getStandings(competitionId);
                let groupStandingsHTML = '';
                
                if (standings.length > 0) {
                    groupStandingsHTML = `
                        <div class="bg-green-800 p-4 rounded shadow">
                            <h3 class="text-lg font-semibold mb-4 text-yellow-400">Classifiche Gironi</h3>
                            <div class="overflow-x-auto">
                                <table class="w-full table-auto standings-table text-sm">
                                    <thead>
                                        <tr class="border-b border-yellow-400">
                                            <th class="text-left py-2 px-2">Pos</th>
                                            <th class="text-left py-2 px-2">Squadra</th>
                                            <th class="text-center py-2 px-2">G</th>
                                            <th class="text-center py-2 px-2">V</th>
                                            <th class="text-center py-2 px-2">N</th>
                                            <th class="text-center py-2 px-2">P</th>
                                            <th class="text-center py-2 px-2">GF</th>
                                            <th class="text-center py-2 px-2">GS</th>
                                            <th class="text-center py-2 px-2">DR</th>
                                            <th class="text-center py-2 px-2 font-bold">Pt</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${standings.map((team, index) => {
                                            let positionClass = '';
                                            if (index === 0) positionClass = 'bg-green-500 bg-opacity-20'; // Primo posto (qualificato)
                                            else if (index === 1) positionClass = 'bg-blue-500 bg-opacity-20'; // Secondo posto (possibile qualificato)
                                            
                                            return `
                                                <tr class="border-b border-green-700 hover:bg-green-700 ${positionClass}">
                                                    <td class="py-1 px-2 font-bold">${index + 1}</td>
                                                    <td class="py-1 px-2 font-semibold">${team.teams.name}</td>
                                                    <td class="text-center py-1 px-2">${team.games_played}</td>
                                                    <td class="text-center py-1 px-2">${team.wins}</td>
                                                    <td class="text-center py-1 px-2">${team.draws}</td>
                                                    <td class="text-center py-1 px-2">${team.losses}</td>
                                                    <td class="text-center py-1 px-2">${team.goals_for}</td>
                                                    <td class="text-center py-1 px-2">${team.goals_against}</td>
                                                    <td class="text-center py-1 px-2">${team.goal_difference > 0 ? '+' : ''}${team.goal_difference}</td>
                                                    <td class="text-center py-1 px-2 font-bold text-yellow-400">${team.points}</td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="mt-2 text-xs text-gray-400">
                                <div class="flex flex-wrap gap-4">
                                    <span class="flex items-center"><span class="w-3 h-3 bg-green-500 bg-opacity-20 rounded mr-1"></span>1¬∞ posto girone (qualificato)</span>
                                    ${groupsCount === 4 ? '<span class="flex items-center"><span class="w-3 h-3 bg-blue-500 bg-opacity-20 rounded mr-1"></span>2¬∞ posto girone (possibile qualificato)</span>' : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }

                standingsContent.innerHTML = eliminationHTML + groupStandingsHTML;
                
            } catch (error) {
                console.error('Errore nel caricamento delle fasi di eliminazione:', error);
                standingsContent.innerHTML = '<p class="text-red-400">Errore nel caricamento delle fasi finali</p>';
            }
        }

        async function loadPublicCalendar(competitionId) {
            try {
                const matchdays = await getMatchdaysByCompetition(competitionId);
                const calendarContent = document.getElementById('public-calendar-content');
                
                if (matchdays.length === 0) {
                    calendarContent.innerHTML = '<p class="text-gray-400 italic">Nessuna giornata programmata</p>';
                    return;
                }

                // Separare giornate completate e future
                const completedMatchdays = [];
                const upcomingMatchdays = [];
                
                matchdays.forEach(matchday => {
                    const hasCompletedMatches = matchday.matches.some(match => match.status === 'completed');
                    const hasScheduledMatches = matchday.matches.some(match => match.status === 'scheduled');
                    
                    if (hasCompletedMatches && !hasScheduledMatches) {
                        completedMatchdays.push(matchday);
                    } else {
                        upcomingMatchdays.push(matchday);
                    }
                });

                let calendarHTML = '';
                
                // Prossime giornate
                if (upcomingMatchdays.length > 0) {
                    calendarHTML += `
                        <h4 class="text-lg font-semibold mb-4 text-yellow-400">üîú Prossime Giornate</h4>
                        <div class="space-y-4 mb-8">
                            ${upcomingMatchdays.map(matchday => `
                                <div class="bg-green-700 p-4 rounded">
                                    <h5 class="font-semibold mb-3 text-yellow-300">
                                        ${matchday.description && ['Finale', 'Semifinali', 'Semifinale', 'Finale 3¬∞ posto', 'Quarti di finale', 'Ottavi di finale', 'Sedicesimi di finale'].includes(matchday.description) 
                                            ? matchday.description 
                                            : `Giornata ${matchday.round_number}${matchday.description ? ` - ${matchday.description}` : ''}`
                                        }
                                        ${matchday.date ? `- ${new Date(matchday.date).toLocaleDateString('it-IT')}` : ''}
                                    </h5>
                                    <div class="space-y-2">
                                        ${matchday.matches.map(match => `
                                            <div class="flex items-center justify-between p-2 bg-green-800 rounded">
                                                <div class="flex items-center space-x-3">
                                                    <span class="font-medium">${match.home_team.name}</span>
                                                    <span class="text-yellow-400 text-sm">vs</span>
                                                    <span class="font-medium">${match.away_team.name}</span>
                                                </div>
                                                <span class="text-sm text-gray-300">Da giocare</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // Giornate completate
                if (completedMatchdays.length > 0) {
                    calendarHTML += `
                        <h4 class="text-lg font-semibold mb-4 text-yellow-400">‚úÖ Giornate Completate</h4>
                        <div class="space-y-4">
                            ${completedMatchdays.reverse().map(matchday => `
                                <div class="bg-green-700 p-4 rounded">
                                    <h5 class="font-semibold mb-3 text-yellow-300">
                                        ${matchday.description && ['Finale', 'Semifinali', 'Semifinale', 'Finale 3¬∞ posto', 'Quarti di finale', 'Ottavi di finale', 'Sedicesimi di finale'].includes(matchday.description) 
                                            ? matchday.description 
                                            : `Giornata ${matchday.round_number}${matchday.description ? ` - ${matchday.description}` : ''}`
                                        }
                                        ${matchday.date ? `- ${new Date(matchday.date).toLocaleDateString('it-IT')}` : ''}
                                    </h5>
                                    <div class="space-y-2">
                                        ${matchday.matches.map(match => `
                                            <div class="flex items-center justify-between p-2 bg-green-800 rounded">
                                                <div class="flex items-center space-x-3">
                                                    <span class="font-medium">${match.home_team.name}</span>
                                                    <span class="text-yellow-400 text-sm">vs</span>
                                                    <span class="font-medium">${match.away_team.name}</span>
                                                </div>
                                                <span class="text-lg font-bold text-green-300">
                                                    ${match.home_score || 0} - ${match.away_score || 0}
                                                </span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                calendarContent.innerHTML = calendarHTML;
                
            } catch (error) {
                console.error('Errore nel caricamento del calendario pubblico:', error);
                document.getElementById('public-calendar-content').innerHTML = '<p class="text-red-400">Errore nel caricamento del calendario</p>';
            }
        }

        async function loadPublicStats(competitionId) {
            try {
                const standings = await getStandings(competitionId);
                const matchdays = await getMatchdaysByCompetition(competitionId);
                const statsContent = document.getElementById('public-stats-content');
                
                if (standings.length === 0) {
                    statsContent.innerHTML = '<p class="text-gray-400 italic">Nessuna statistica disponibile</p>';
                    return;
                }

                // Calcola statistiche interessanti
                const totalMatches = matchdays.reduce((sum, matchday) => 
                    sum + matchday.matches.filter(match => match.status === 'completed').length, 0);
                
                const totalGoals = standings.reduce((sum, team) => sum + team.goals_for, 0);
                const avgGoalsPerMatch = totalMatches > 0 ? (totalGoals / totalMatches).toFixed(1) : 0;
                
                const bestAttack = standings.reduce((best, team) => 
                    team.goals_for > best.goals_for ? team : best, standings[0]);
                
                const bestDefense = standings.reduce((best, team) => 
                    team.goals_against < best.goals_against ? team : best, standings[0]);

                const statsHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Statistiche Generali -->
                        <div class="bg-green-700 p-4 rounded">
                            <h4 class="text-lg font-semibold mb-3 text-yellow-300">üìä Statistiche Generali</h4>
                            <div class="space-y-2 text-sm">
                                <div class="flex justify-between">
                                    <span>Partite giocate:</span>
                                    <span class="font-bold">${totalMatches}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Gol totali:</span>
                                    <span class="font-bold">${totalGoals}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Media gol/partita:</span>
                                    <span class="font-bold">${avgGoalsPerMatch}</span>
                                </div>
                            </div>
                        </div>

                        <!-- Migliori Squadre -->
                        <div class="bg-green-700 p-4 rounded">
                            <h4 class="text-lg font-semibold mb-3 text-yellow-300">üèÜ Migliori Squadre</h4>
                            <div class="space-y-2 text-sm">
                                <div class="flex justify-between">
                                    <span>Miglior attacco:</span>
                                    <span class="font-bold">${bestAttack.teams.name} (${bestAttack.goals_for} gol)</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Miglior difesa:</span>
                                    <span class="font-bold">${bestDefense.teams.name} (${bestDefense.goals_against} gol subiti)</span>
                                </div>
                            </div>
                        </div>

                        <!-- Andamento Squadre -->
                        <div class="bg-green-700 p-4 rounded md:col-span-2">
                            <h4 class="text-lg font-semibold mb-3 text-yellow-300">üìà Rendimento Squadre</h4>
                            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                                ${standings.map((team, index) => {
                                    const winRate = team.games_played > 0 ? ((team.wins / team.games_played) * 100).toFixed(1) : 0;
                                    const avgGoalsFor = team.games_played > 0 ? (team.goals_for / team.games_played).toFixed(1) : 0;
                                    const avgGoalsAgainst = team.games_played > 0 ? (team.goals_against / team.games_played).toFixed(1) : 0;
                                    
                                    return `
                                        <div class="bg-green-800 p-3 rounded">
                                            <h5 class="font-semibold mb-2 text-yellow-400">${team.teams.name}</h5>
                                            <div class="text-xs space-y-1">
                                                <div class="flex justify-between">
                                                    <span>% Vittorie:</span>
                                                    <span class="font-bold">${winRate}%</span>
                                                </div>
                                                <div class="flex justify-between">
                                                    <span>Media gol fatti:</span>
                                                    <span class="font-bold">${avgGoalsFor}</span>
                                                </div>
                                                <div class="flex justify-between">
                                                    <span>Media gol subiti:</span>
                                                    <span class="font-bold">${avgGoalsAgainst}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;

                statsContent.innerHTML = statsHTML;
                
            } catch (error) {
                console.error('Errore nel caricamento delle statistiche:', error);
                document.getElementById('public-stats-content').innerHTML = '<p class="text-red-400">Errore nel caricamento delle statistiche</p>';
            }
        }

        async function loadCompetitionSelects() {
            try {
                const competitions = await getAllCompetitions();
                const calendarSelect = document.getElementById('calendar-competition-select');
                const standingsSelect = document.getElementById('standings-competition-select');
                
                // Popola le select
                const optionsHTML = competitions.map(comp => 
                    `<option value="${comp.id}">${comp.name} (${getTypeLabel(comp.type)})</option>`
                ).join('');
                
                calendarSelect.innerHTML = '<option value="">Seleziona un campionato...</option>' + optionsHTML;
                standingsSelect.innerHTML = '<option value="">Seleziona un campionato...</option>' + optionsHTML;
                
            } catch (error) {
                console.error('Errore nel caricamento delle select:', error);
            }
        }

        async function loadCalendar(competitionId) {
            try {
                const matchdays = await getMatchdaysByCompetition(competitionId);
                const calendarContent = document.getElementById('calendar-content');
                
                if (matchdays.length === 0) {
                    calendarContent.innerHTML = '<p class="text-gray-400 italic">Nessuna giornata programmata</p>';
                    return;
                }

                const calendarHTML = matchdays.map(matchday => {
                    // Raggruppa le partite per girone se presente
                    const matchesByGroup = {};
                    const noGroupMatches = [];
                    
                    matchday.matches.forEach(match => {
                        if (match.group_letter) {
                            if (!matchesByGroup[match.group_letter]) {
                                matchesByGroup[match.group_letter] = [];
                            }
                            matchesByGroup[match.group_letter].push(match);
                        } else {
                            noGroupMatches.push(match);
                        }
                    });
                    
                    return `
                        <div class="bg-green-800 p-6 rounded shadow">
                            <h3 class="text-xl font-semibold mb-4 text-yellow-400">
                                ${matchday.description && ['Finale', 'Semifinali', 'Semifinale', 'Finale 3¬∞ posto', 'Quarti di finale', 'Ottavi di finale', 'Sedicesimi di finale'].includes(matchday.description) 
                                    ? matchday.description 
                                    : `Giornata ${matchday.round_number}${matchday.description ? ` - ${matchday.description}` : ''}`
                                }
                                ${matchday.date ? ` - ${new Date(matchday.date).toLocaleDateString('it-IT')}` : ''}
                            </h3>
                            
                            ${Object.keys(matchesByGroup).length > 0 ? 
                                Object.keys(matchesByGroup).sort().map(groupLetter => `
                                    <div class="mb-6">
                                        <h4 class="text-lg font-medium mb-3 text-blue-300">Girone ${groupLetter}</h4>
                                        <div class="space-y-3">
                                            ${matchesByGroup[groupLetter].map(match => generateMatchHTML(match)).join('')}
                                        </div>
                                    </div>
                                `).join('') : ''
                            }
                            
                            ${noGroupMatches.length > 0 ? `
                                <div class="space-y-3">
                                    ${noGroupMatches.map(match => generateMatchHTML(match)).join('')}
                                </div>
                            ` : `
                                ${Object.keys(matchesByGroup).length === 0 ? `
                                    <div class="text-center py-4 text-gray-400 italic">
                                        ${matchday.description && ['Finale', 'Semifinali', 'Semifinale', 'Finale 3¬∞ posto', 'Quarti di finale', 'Ottavi di finale', 'Sedicesimi di finale'].includes(matchday.description) 
                                            ? 'Nessuna partita generata ancora. Usa il pulsante delle fasi finali per creare le partite.' 
                                            : 'Nessuna partita programmata per questa giornata'
                                        }
                                    </div>
                                ` : ''}`
                            }
                        </div>
                    `;
                }).join('');

                calendarContent.innerHTML = calendarHTML;
                
            } catch (error) {
                console.error('Errore nel caricamento del calendario:', error);
                document.getElementById('calendar-content').innerHTML = '<p class="text-red-400">Errore nel caricamento del calendario</p>';
            }
        }

        // Funzione helper per generare HTML delle partite
        function generateMatchHTML(match) {
            return `
                <div class="flex items-center justify-between p-3 bg-green-700 rounded">
                    <div class="flex items-center space-x-4">
                        <span class="font-semibold">${match.home_team.name}</span>
                        <span class="text-yellow-400">VS</span>
                        <span class="font-semibold">${match.away_team.name}</span>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        ${match.status === 'completed' ? 
                            `<span class="text-green-300 font-bold">${match.home_score || 0} - ${match.away_score || 0}</span>
                             <button onclick="openMatchResultModal('${match.id}', '${match.home_team.name}', '${match.away_team.name}', '${match.home_team.id}', '${match.away_team.id}', ${match.home_score || 0}, ${match.away_score || 0})" 
                                     class="bg-blue-600 hover:bg-blue-700 text-white px-2 py-1 rounded text-sm">
                                Modifica
                            </button>` :
                            `<button onclick="openMatchResultModal('${match.id}', '${match.home_team.name}', '${match.away_team.name}', '${match.home_team.id}', '${match.away_team.id}', null, null)" 
                                     class="bg-yellow-400 text-green-900 px-3 py-1 rounded text-sm hover:bg-yellow-300">
                                Inserisci Risultato
                            </button>`
                        }
                    </div>
                </div>
            `;
        }

        async function loadStandings(competitionId) {
            try {
                // Prima ottieni i dettagli della competizione per determinare il tipo
                const { data: competition, error: compError } = await supabaseClient
                    .from('competitions')
                    .select('type, groups_count')
                    .eq('id', competitionId)
                    .single();
                
                if (compError) throw compError;
                
                const standingsContent = document.getElementById('standings-content');
                
                // Se √® una coppa, mostra le fasi di eliminazione con evidenza
                if (competition.type === 'cup') {
                    await loadCupEliminationStandings(competitionId, competition.groups_count, standingsContent);
                } else {
                    // Classifica normale per le leghe
                    const standings = await getStandings(competitionId);
                    
                    if (standings.length === 0) {
                        standingsContent.innerHTML = '<p class="text-gray-400 italic">Nessuna classifica disponibile</p>';
                        return;
                    }

                    const standingsHTML = `
                        <table class="w-full table-auto standings-table">
                            <thead>
                                <tr class="border-b border-yellow-400">
                                    <th class="text-left py-2 px-3">Pos</th>
                                    <th class="text-left py-2 px-3">Squadra</th>
                                    <th class="text-center py-2 px-3">G</th>
                                    <th class="text-center py-2 px-3">V</th>
                                    <th class="text-center py-2 px-3">N</th>
                                    <th class="text-center py-2 px-3">P</th>
                                    <th class="text-center py-2 px-3">GF</th>
                                    <th class="text-center py-2 px-3">GS</th>
                                    <th class="text-center py-2 px-3">DR</th>
                                    <th class="text-center py-2 px-3 font-bold">Pt</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${standings.map((team, index) => `
                                    <tr class="border-b border-green-700 hover:bg-green-700">
                                        <td class="py-2 px-3 font-bold">${index + 1}</td>
                                        <td class="py-2 px-3 font-semibold">${team.teams.name}</td>
                                        <td class="text-center py-2 px-3">${team.games_played}</td>
                                        <td class="text-center py-2 px-3">${team.wins}</td>
                                        <td class="text-center py-2 px-3">${team.draws}</td>
                                        <td class="text-center py-2 px-3">${team.losses}</td>
                                        <td class="text-center py-2 px-3">${team.goals_for}</td>
                                        <td class="text-center py-2 px-3">${team.goals_against}</td>
                                        <td class="text-center py-2 px-3">${team.goal_difference > 0 ? '+' : ''}${team.goal_difference}</td>
                                        <td class="text-center py-2 px-3 font-bold text-yellow-400">${team.points}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;

                    standingsContent.innerHTML = standingsHTML;
                }
                
            } catch (error) {
                console.error('Errore nel caricamento della classifica:', error);
                standingsContent.innerHTML = '<p class="text-red-400">Errore nel caricamento della classifica</p>';
            }
        }

        async function generateCalendarForCompetition(competitionId) {
            try {
                // Verifica se esistono gi√† giornate per questa competizione
                const { data: existingMatchdays, error: checkError } = await supabaseClient
                    .from('matchdays')
                    .select('id')
                    .eq('competition_id', competitionId)
                    .limit(1);
                
                if (checkError) throw checkError;
                
                // Se esistono gi√† giornate, chiedi conferma prima di cancellare
                if (existingMatchdays && existingMatchdays.length > 0) {
                    const confirmDelete = confirm(
                        '‚ö†Ô∏è ATTENZIONE: Esiste gi√† un calendario per questa competizione.\n\n' +
                        'Rigenerare il calendario canceller√†:\n' +
                        '‚Ä¢ Tutte le giornate esistenti\n' +
                        '‚Ä¢ Tutti i risultati inseriti\n' +
                        '‚Ä¢ Tutta la classifica attuale\n\n' +
                        'Sei sicuro di voler continuare?'
                    );
                    
                    if (!confirmDelete) {
                        showError('Generazione calendario annullata dall\'utente');
                        return;
                    }
                    
                    // Solo ora elimina il calendario esistente
                    await clearExistingCalendar(competitionId);
                }
                
                // Ottieni informazioni sulla competizione
                const { data: competition, error: compError } = await supabaseClient
                    .from('competitions')
                    .select('type, groups_count')
                    .eq('id', competitionId)
                    .single();
                
                if (compError) throw compError;
                
                console.log(`üèÜ Generazione calendario per competizione:`, {
                    id: competitionId,
                    type: competition.type,
                    groups_count: competition.groups_count
                });
                
                const teams = await getTeamsByCompetition(competitionId);
                console.log(`üë• Squadre trovate: ${teams.length}`, teams.map(t => t.name));
                
                if (teams.length < 2) {
                    alert('Servono almeno 2 squadre per generare il calendario');
                    return;
                }

                if (competition.type === 'cup') {
                    console.log('üèÜ Generazione calendario COPPA');
                    await generateCupCalendar(competitionId, teams, competition.groups_count || 2);
                } else if (competition.type === 'elimination') {
                    console.log('üèÜ Generazione calendario ELIMINAZIONE');
                    await generateEliminationCalendar(competitionId, teams);
                } else {
                    console.log('üèÜ Generazione calendario CAMPIONATO ALL\'ITALIANA');
                    // Campionato all'italiana
                    const schedule = generateRoundRobinSchedule(teams);
                    
                    // Crea le giornate e partite nel database
                    for (const round of schedule) {
                        // Crea la giornata
                        const matchday = await createMatchday(competitionId, round.round, null);
                        
                        // Crea le partite
                        for (const match of round.matches) {
                            await createMatch(matchday.id, match.home_team.id, match.away_team.id);
                        }
                    }
                }

                // Ricarica il calendario
                await loadCalendar(competitionId);
                showSuccess('Calendario generato con successo!');
                
            } catch (error) {
                console.error('Errore nella generazione del calendario:', error);
                showError('Errore nella generazione del calendario: ' + error.message);
            }
        }

        // Funzione per cancellare il calendario esistente
        async function clearExistingCalendar(competitionId) {
            try {
                // Prima ottieni gli ID delle giornate di questa competizione
                const { data: matchdays, error: matchdaysSelectError } = await supabaseClient
                    .from('matchdays')
                    .select('id')
                    .eq('competition_id', competitionId);

                if (matchdaysSelectError) {
                    console.log('Errore nel recupero delle giornate:', matchdaysSelectError);
                    return;
                }

                if (matchdays && matchdays.length > 0) {
                    const matchdayIds = matchdays.map(md => md.id);
                    
                    // Elimina tutte le partite di queste giornate
                    const { error: matchesError } = await supabaseClient
                        .from('matches')
                        .delete()
                        .in('matchday_id', matchdayIds);

                    if (matchesError) {
                        console.log('Errore nell\'eliminazione delle partite:', matchesError);
                    }

                    // Poi elimina tutte le giornate di questa competizione
                    const { error: matchdaysError } = await supabaseClient
                        .from('matchdays')
                        .delete()
                        .eq('competition_id', competitionId);

                    if (matchdaysError) {
                        console.log('Errore nell\'eliminazione delle giornate:', matchdaysError);
                        throw matchdaysError;
                    }
                }
                
                console.log('‚úÖ Calendario esistente cancellato per la competizione:', competitionId);
                
            } catch (error) {
                console.log('Errore nella cancellazione del calendario esistente:', error);
                throw error; // Rilancia l'errore per evitare duplicati
            }
        }

        async function loadCompetitions() {
            try {
                const competitions = await getAllCompetitions();
                const competitionsList = document.getElementById('competitions-list');
                
                if (competitions.length === 0) {
                    competitionsList.innerHTML = '<p class="text-gray-400 italic">Nessun campionato creato</p>';
                    return;
                }
                
                competitionsList.innerHTML = competitions.map(comp => `
                    <div class="bg-green-800 p-4 rounded-lg flex justify-between items-center">
                        <div>
                            <h3 class="font-semibold">${comp.name}</h3>
                            <p class="text-sm text-gray-300">Tipo: ${getTypeLabel(comp.type)} | Stagione: ${comp.season || '2024/2025'}</p>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="openEditModal('${comp.id}', '${comp.name}', '${comp.type}', '${comp.season || '2024/2025'}')" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm">
                                Modifica
                            </button>
                            <button onclick="removeCompetition('${comp.id}')" 
                                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">
                                Elimina
                            </button>
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Errore nel caricamento dei campionati:', error);
                showError('Errore nel caricamento dei campionati: ' + error.message);
            }
        }

        function openTeamsCreationModal(competitionId, competitionName, competitionType) {
            const modal = document.getElementById('teams-creation-modal');
            modal.dataset.competitionId = competitionId;
            document.getElementById('creation-competition-name').textContent = competitionName;
            document.getElementById('creation-competition-type').textContent = getTypeLabel(competitionType);
            modal.classList.remove('hidden');
            updateCreationTeamsList(competitionId);
        }

        function closeTeamsCreationModal() {
            document.getElementById('teams-creation-modal').classList.add('hidden');
            document.getElementById('new-team-name').value = '';
        }

        async function updateCreationTeamsList(competitionId) {
            try {
                const teams = await getTeamsByCompetition(competitionId);
                const teamsList = document.getElementById('creation-teams-list');
                const teamsCount = document.getElementById('teams-count');
                const warning = document.getElementById('odd-teams-warning');
                const competitionType = document.getElementById('creation-competition-type').textContent;
                
                teamsCount.textContent = teams.length;
                
                if (competitionType.includes('italiana') && teams.length > 0 && teams.length % 2 !== 0) {
                    warning.classList.remove('hidden');
                } else {
                    warning.classList.add('hidden');
                }
                
                if (teams.length === 0) {
                    teamsList.innerHTML = '<p class="text-gray-400 italic">Nessuna squadra aggiunta</p>';
                    return;
                }
                
                teamsList.innerHTML = teams.map(team => `
                    <div class="flex justify-between items-center p-2 bg-gray-100 rounded">
                        <span class="text-gray-800">${team.name}</span>
                        <button onclick="removeTeamFromCompetitionInModal('${team.id}', '${competitionId}')" 
                                class="text-red-600 hover:text-red-800 font-bold">√ó</button>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Errore nel caricamento delle squadre:', error);
            }
        }

        async function updateEditTeamsList(competitionId) {
            try {
                const teams = await getTeamsByCompetition(competitionId);
                const teamsList = document.getElementById('edit-teams-list');
                const teamsCount = document.getElementById('edit-teams-count');
                const warning = document.getElementById('edit-odd-teams-warning');
                const competitionType = document.getElementById('edit-competition-type').value;
                
                teamsCount.textContent = teams.length;
                
                if (competitionType === 'all-against-all' && teams.length > 0 && teams.length % 2 !== 0) {
                    warning.classList.remove('hidden');
                } else {
                    warning.classList.add('hidden');
                }
                
                if (teams.length === 0) {
                    teamsList.innerHTML = '<p class="text-gray-400 italic">Nessuna squadra nel campionato</p>';
                    return;
                }
                
                teamsList.innerHTML = teams.map(team => `
                    <div class="flex justify-between items-center p-2 bg-gray-100 rounded">
                        <span class="text-gray-800">${team.name}</span>
                        <button onclick="removeTeamFromCompetitionInModal('${team.id}', '${competitionId}')" 
                                class="text-red-600 hover:text-red-800 font-bold">√ó</button>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Errore nel caricamento delle squadre:', error);
            }
        }

        function closeEditModal() {
            document.getElementById('edit-competition-modal').classList.add('hidden');
            document.getElementById('edit-new-team-name').value = '';
        }

        // Funzioni globali per i callback
        window.removeCompetition = async function(competitionId) {
            if (!confirm('Sei veramente sicuro di voler eliminare questo campionato?\n\nATTENZIONE: Il campionato verr√† disattivato e non sar√† pi√π visibile, ma i dati rimarranno nel database per eventuali ripristini futuri.\n\nPremere OK per confermare l\'eliminazione.')) return;
            
            try {
                await deleteCompetition(competitionId);
                await loadCompetitions();
                await loadCompetitionSelects();
                showSuccess('Campionato eliminato con successo');
            } catch (error) {
                showError('Errore nell\'eliminazione del campionato: ' + error.message);
            }
        }

        window.openEditModal = async function(competitionId, competitionName, competitionType, competitionSeason) {
            const modal = document.getElementById('edit-competition-modal');
            modal.dataset.competitionId = competitionId;
            document.getElementById('edit-competition-name').value = competitionName;
            document.getElementById('edit-competition-type').value = competitionType;
            
            // Gestisce la visibilit√† dei campi gironi
            const cupGroupsContainer = document.getElementById('edit-cup-groups-container');
            if (competitionType === 'cup') {
                cupGroupsContainer.style.display = 'block';
                // Carica il numero di gironi esistente se disponibile
                try {
                    const { data: competition, error } = await supabaseClient
                        .from('competitions')
                        .select('groups_count')
                        .eq('id', competitionId)
                        .single();
                    
                    if (!error && competition.groups_count) {
                        document.getElementById('edit-cup-groups').value = competition.groups_count;
                    }
                } catch (error) {
                    console.log('Errore nel caricamento dei gironi:', error);
                }
            } else {
                cupGroupsContainer.style.display = 'none';
            }
            
            modal.classList.remove('hidden');
            await updateEditTeamsList(competitionId);
        }

        // Funzione per aprire il modal di modifica risultati
        window.openEditResultsModal = async function(competitionId, competitionName) {
            const modal = document.getElementById('edit-results-modal');
            modal.dataset.competitionId = competitionId;
            document.getElementById('edit-results-competition-name').textContent = competitionName;
            modal.classList.remove('hidden');
            await loadEditResultsMatchdays(competitionId);
        }

        // Carica le giornate per la modifica risultati
        async function loadEditResultsMatchdays(competitionId) {
            try {
                const { data: matchdays, error } = await supabaseClient
                    .from('matchdays')
                    .select('*')
                    .eq('competition_id', competitionId)
                    .order('round_number');

                if (error) throw error;

                const select = document.getElementById('edit-results-matchday-select');
                
                if (matchdays.length === 0) {
                    select.innerHTML = '<option value="">Nessuna giornata trovata</option>';
                    return;
                }

                select.innerHTML = '<option value="">Seleziona una giornata</option>' + 
                    matchdays.map(md => `<option value="${md.id}">${md.description && ['Finale', 'Semifinali', 'Semifinale', 'Finale 3¬∞ posto', 'Quarti di finale', 'Ottavi di finale', 'Sedicesimi di finale'].includes(md.description) ? md.description : `Giornata ${md.round_number}${md.description ? ` - ${md.description}` : ''}`}</option>`).join('');
                
            } catch (error) {
                console.error('Errore nel caricamento delle giornate:', error);
                showError('Errore nel caricamento delle giornate: ' + error.message);
            }
        }

        // Carica le partite di una giornata specifica per la modifica
        async function loadEditResultsMatches(matchdayId) {
            try {
                const { data: matches, error } = await supabaseClient
                    .from('matches')
                    .select(`
                        *,
                        home_team:teams!matches_home_team_id_fkey(id, name),
                        away_team:teams!matches_away_team_id_fkey(id, name)
                    `)
                    .eq('matchday_id', matchdayId)
                    .order('created_at');

                if (error) throw error;

                const container = document.getElementById('edit-results-matches-container');
                
                if (matches.length === 0) {
                    container.innerHTML = '<p class="text-gray-500 italic">Nessuna partita trovata per questa giornata</p>';
                    return;
                }

                container.innerHTML = matches.map(match => `
                    <div class="bg-gray-50 p-4 rounded-lg border">
                        <div class="flex items-center justify-between mb-2">
                            <div class="font-semibold text-gray-800">
                                ${match.home_team.name} vs ${match.away_team.name}
                            </div>
                            <div class="text-sm text-gray-600">
                                ${match.home_score !== null && match.away_score !== null 
                                    ? `Risultato: ${match.home_score} - ${match.away_score}` 
                                    : 'Non giocata'}
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Gol ${match.home_team.name}</label>
                                <input type="number" id="edit-home-score-${match.id}" 
                                       value="${match.home_score || ''}" 
                                       min="0" max="99" 
                                       class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-500">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Gol ${match.away_team.name}</label>
                                <input type="number" id="edit-away-score-${match.id}" 
                                       value="${match.away_score || ''}" 
                                       min="0" max="99" 
                                       class="w-full px-3 py-2 border rounded text-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-500">
                            </div>
                        </div>
                        <div class="mt-3 flex justify-end">
                            <button onclick="saveIndividualResult('${match.id}')" 
                                    class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm">
                                Salva Risultato
                            </button>
                        </div>
                    </div>
                `).join('');

                // Mostra il pulsante per salvare tutti i risultati
                document.getElementById('save-all-results').classList.remove('hidden');
                
            } catch (error) {
                console.error('Errore nel caricamento delle partite:', error);
                showError('Errore nel caricamento delle partite: ' + error.message);
            }
        }

        // Salva il risultato di una singola partita
        window.saveIndividualResult = async function(matchId) {
            try {
                const homeScore = document.getElementById(`edit-home-score-${matchId}`).value;
                const awayScore = document.getElementById(`edit-away-score-${matchId}`).value;

                if (homeScore === '' || awayScore === '') {
                    showError('Inserisci entrambi i punteggi');
                    return;
                }

                await updateMatchResult(matchId, parseInt(homeScore), parseInt(awayScore));
                
                // Aggiorna automaticamente tutte le visualizzazioni
                const competitionId = document.getElementById('edit-results-modal').dataset.competitionId;
                if (competitionId) {
                    // Aggiorna la classifica pubblica se √® la stessa competizione
                    const publicCompetitionId = document.getElementById('public-competition-select').value;
                    if (publicCompetitionId === competitionId) {
                        await loadPublicStandings(competitionId);
                        await loadPublicStats(competitionId);
                    }
                    
                    // Aggiorna la classifica admin se √® la stessa competizione
                    const adminCompetitionId = document.getElementById('standings-competition-select').value;
                    if (adminCompetitionId === competitionId) {
                        await loadStandings(competitionId);
                    }
                    
                    // Aggiorna il calendario admin se √® la stessa competizione
                    const calendarCompetitionId = document.getElementById('calendar-competition-select').value;
                    if (calendarCompetitionId === competitionId) {
                        await loadCalendar(competitionId);
                    }
                }
                
                showSuccess('Risultato salvato con successo');
                
            } catch (error) {
                console.error('Errore nel salvataggio del risultato:', error);
                showError('Errore nel salvataggio del risultato: ' + error.message);
            }
        }

        // Salva tutti i risultati della giornata
        window.saveAllResults = async function() {
            try {
                const matchdayId = document.getElementById('edit-results-matchday-select').value;
                if (!matchdayId) {
                    showError('Seleziona una giornata');
                    return;
                }

                // Ottieni tutte le partite della giornata
                const { data: matches, error } = await supabaseClient
                    .from('matches')
                    .select('id')
                    .eq('matchday_id', matchdayId);

                if (error) throw error;

                let savedCount = 0;
                let errorCount = 0;

                for (const match of matches) {
                    try {
                        const homeScore = document.getElementById(`edit-home-score-${match.id}`).value;
                        const awayScore = document.getElementById(`edit-away-score-${match.id}`).value;

                        if (homeScore !== '' && awayScore !== '') {
                            await updateMatchResult(match.id, parseInt(homeScore), parseInt(awayScore));
                            savedCount++;
                        }
                    } catch (error) {
                        console.error(`Errore nel salvataggio della partita ${match.id}:`, error);
                        errorCount++;
                    }
                }

                // Aggiorna automaticamente tutte le visualizzazioni
                const competitionId = document.getElementById('edit-results-modal').dataset.competitionId;
                if (competitionId) {
                    // Aggiorna la classifica pubblica se √® la stessa competizione
                    const publicCompetitionId = document.getElementById('public-competition-select').value;
                    if (publicCompetitionId === competitionId) {
                        await loadPublicStandings(competitionId);
                        await loadPublicStats(competitionId);
                    }
                    
                    // Aggiorna la classifica admin se √® la stessa competizione
                    const adminCompetitionId = document.getElementById('standings-competition-select').value;
                    if (adminCompetitionId === competitionId) {
                        await loadStandings(competitionId);
                    }
                    
                    // Aggiorna il calendario admin se √® la stessa competizione
                    const calendarCompetitionId = document.getElementById('calendar-competition-select').value;
                    if (calendarCompetitionId === competitionId) {
                        await loadCalendar(competitionId);
                    }
                }

                if (savedCount > 0) {
                    showSuccess(`${savedCount} risultati salvati con successo`);
                }
                if (errorCount > 0) {
                    showError(`${errorCount} errori nel salvataggio`);
                }
                
            } catch (error) {
                console.error('Errore nel salvataggio dei risultati:', error);
                showError('Errore nel salvataggio dei risultati: ' + error.message);
            }
        }

        window.removeTeamFromCompetitionInModal = async function(teamId, competitionId) {
            if (!confirm('Sei sicuro di voler rimuovere questa squadra dal campionato?')) return;
            
            try {
                await removeTeamFromCompetition(teamId, competitionId);
                
                if (!document.getElementById('teams-creation-modal').classList.contains('hidden')) {
                    await updateCreationTeamsList(competitionId);
                }
                if (!document.getElementById('edit-competition-modal').classList.contains('hidden')) {
                    await updateEditTeamsList(competitionId);
                }
            } catch (error) {
                alert('Errore nella rimozione della squadra: ' + error.message);
            }
        }

        window.openMatchResultModal = function(matchId, homeTeam, awayTeam, homeTeamId, awayTeamId, homeScore = null, awayScore = null) {
            const modal = document.getElementById('match-result-modal');
            modal.dataset.matchId = matchId;
            modal.dataset.homeTeamId = homeTeamId;
            modal.dataset.awayTeamId = awayTeamId;
            
            document.getElementById('match-teams').textContent = `${homeTeam} vs ${awayTeam}`;
            document.getElementById('home-team-label').textContent = homeTeam;
            document.getElementById('away-team-label').textContent = awayTeam;
            
            // Imposta i valori esistenti se ci sono
            document.getElementById('home-score').value = homeScore !== null ? homeScore : '';
            document.getElementById('away-score').value = awayScore !== null ? awayScore : '';
            
            modal.classList.remove('hidden');
        }

        // Inizializzazione pagina
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await initSupabase();
                console.log('‚úÖ Inizializzazione completata');
                
                // Carica i campionati pubblici
                await loadPublicCompetitions();
                
                // Elementi DOM
                const adminSection = document.getElementById('admin-section');
                const emailInput = document.getElementById('email');
                const passwordInput = document.getElementById('password');
                const loginBtn = document.getElementById('login-btn');
                const logoutBtn = document.getElementById('logout-btn');

                // Event listeners per la sezione pubblica
                document.getElementById('public-competition-select').addEventListener('change', async (e) => {
                    const competitionId = e.target.value;
                    const publicTabs = document.getElementById('public-tabs');
                    
                    if (competitionId) {
                        publicTabs.style.display = 'block';
                        await loadPublicStandings(competitionId);
                        showPublicTab('standings');
                    } else {
                        publicTabs.style.display = 'none';
                        document.getElementById('public-standings-content').innerHTML = '<p class="text-gray-400 italic">Seleziona un campionato per visualizzare la classifica</p>';
                        document.getElementById('public-calendar-content').innerHTML = '<p class="text-gray-400 italic">Seleziona un campionato per visualizzare il calendario</p>';
                        document.getElementById('public-stats-content').innerHTML = '<p class="text-gray-400 italic">Seleziona un campionato per visualizzare le statistiche</p>';
                    }
                });

                document.getElementById('public-tab-standings').addEventListener('click', async () => {
                    const competitionId = document.getElementById('public-competition-select').value;
                    if (competitionId) {
                        showPublicTab('standings');
                        await loadPublicStandings(competitionId);
                    }
                });

                document.getElementById('public-tab-calendar').addEventListener('click', async () => {
                    const competitionId = document.getElementById('public-competition-select').value;
                    if (competitionId) {
                        showPublicTab('calendar');
                        await loadPublicCalendar(competitionId);
                    }
                });

                document.getElementById('public-tab-stats').addEventListener('click', async () => {
                    const competitionId = document.getElementById('public-competition-select').value;
                    if (competitionId) {
                        showPublicTab('stats');
                        await loadPublicStats(competitionId);
                    }
                });

                // Controllo iniziale autenticazione
                try {
                    const user = await getCurrentUser();
                    if (user) {
                        adminSection.classList.remove('hidden');
                        logoutBtn.classList.remove('hidden');
                        showSuccess(`Benvenuto ${user.email}`);
                        setupActivityListeners(); // Attiva monitoraggio inattivit√†
                        resetLogoutTimer(); // Inizia timer logout
                        await loadCompetitions();
                    }
                } catch (error) {
                    console.error('Errore controllo utente:', error);
                }

                // Login
                loginBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const email = emailInput.value.trim();
                    const password = passwordInput.value;

                    console.log('üîê Tentativo di login per:', email);

                    // Validazione input rafforzata
                    if (!email || !password) {
                        showError('Inserisci email e password');
                        return;
                    }

                    // Rate limiting basic (max 5 tentativi in 5 minuti)
                    const now = Date.now();
                    if (now - lastLoginAttempt < 60000 && loginAttempts >= 5) {
                        showError('Troppi tentativi di login. Riprova tra un minuto.');
                        return;
                    }
                    
                    if (now - lastLoginAttempt > 300000) { // Reset dopo 5 minuti
                        loginAttempts = 0;
                    }
                    
                    loginAttempts++;
                    lastLoginAttempt = now;

                    // Validazione formato email
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    if (!emailRegex.test(email)) {
                        showError('Formato email non valido');
                        return;
                    }

                    // Limitazione lunghezza password (evita attacchi DoS)
                    if (password.length > 128) {
                        showError('Password troppo lunga');
                        return;
                    }

                    loginBtn.textContent = 'Accesso...';
                    loginBtn.disabled = true;

                    try {
                        console.log('üì° Chiamata login...');
                        const result = await login(email, password);
                        console.log('‚úÖ Login riuscito:', result);
                        
                        // Reset contatori su login riuscito
                        loginAttempts = 0;
                        
                        adminSection.classList.remove('hidden');
                        logoutBtn.classList.remove('hidden');
                        emailInput.value = '';
                        passwordInput.value = '';
                        showSuccess('Accesso effettuato con successo');
                        setupActivityListeners(); // Attiva monitoraggio inattivit√†
                        resetLogoutTimer(); // Inizia timer logout
                        await loadCompetitions();
                    } catch (error) {
                        console.error('‚ùå Errore login:', error);
                        // Non esporre dettagli dell'errore per sicurezza
                        showError('Credenziali non valide o errore di connessione');
                    } finally {
                        loginBtn.textContent = 'Accedi';
                        loginBtn.disabled = false;
                    }
                });

                // Logout
                logoutBtn.addEventListener('click', async () => {
                    try {
                        await logout();
                        if (logoutTimer) {
                            clearTimeout(logoutTimer); // Pulisce timer
                        }
                        adminSection.classList.add('hidden');
                        logoutBtn.classList.add('hidden');
                        showSuccess('Logout effettuato con successo');
                    } catch (error) {
                        showError('Errore durante il logout: ' + error.message);
                    }
                });

                // Event listener per mostrare/nascondere campi gironi
                document.getElementById('competition-type').addEventListener('change', (e) => {
                    const cupGroupsContainer = document.getElementById('cup-groups-container');
                    if (e.target.value === 'cup') {
                        cupGroupsContainer.style.display = 'block';
                    } else {
                        cupGroupsContainer.style.display = 'none';
                    }
                });

                // Creazione campionato
                document.getElementById('competition-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const name = document.getElementById('competition-name').value.trim();
                    const type = document.getElementById('competition-type').value;
                    const groupsCount = type === 'cup' ? parseInt(document.getElementById('cup-groups').value) : null;
                    
                    if (!name) {
                        showError('Inserisci il nome del campionato');
                        return;
                    }

                    try {
                        const competition = await createCompetition(name, type, '2024/2025', groupsCount);
                        await loadCompetitions();
                        await loadPublicCompetitions();
                        e.target.reset();
                        // Reset visibility of cup groups
                        document.getElementById('cup-groups-container').style.display = 'none';
                        openTeamsCreationModal(competition.id, competition.name, competition.type);
                        showSuccess('Campionato creato con successo: ' + competition.name);
                    } catch (error) {
                        showError('Errore nella creazione del campionato: ' + error.message);
                    }
                });

                // Aggiunta squadre durante creazione
                document.getElementById('team-creation-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const teamName = document.getElementById('new-team-name').value.trim();
                    const competitionId = document.getElementById('teams-creation-modal').dataset.competitionId;
                    
                    if (!teamName) return;
                    
                    try {
                        await createTeam(teamName, competitionId);
                        document.getElementById('new-team-name').value = '';
                        await updateCreationTeamsList(competitionId);
                    } catch (error) {
                        alert('Errore nell\'aggiunta della squadra: ' + error.message);
                    }
                });

                // Aggiunta squadre durante modifica
                document.getElementById('edit-team-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const teamName = document.getElementById('edit-new-team-name').value.trim();
                    const competitionId = document.getElementById('edit-competition-modal').dataset.competitionId;
                    
                    if (!teamName) return;
                    
                    try {
                        await createTeam(teamName, competitionId);
                        document.getElementById('edit-new-team-name').value = '';
                        await updateEditTeamsList(competitionId);
                    } catch (error) {
                        alert('Errore nell\'aggiunta della squadra: ' + error.message);
                    }
                });

                // Event listener per mostrare/nascondere campi gironi nel form di modifica
                document.getElementById('edit-competition-type').addEventListener('change', (e) => {
                    const cupGroupsContainer = document.getElementById('edit-cup-groups-container');
                    if (e.target.value === 'cup') {
                        cupGroupsContainer.style.display = 'block';
                    } else {
                        cupGroupsContainer.style.display = 'none';
                    }
                });

                // Modifica campionato
                document.getElementById('edit-competition-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const competitionId = document.getElementById('edit-competition-modal').dataset.competitionId;
                    const name = document.getElementById('edit-competition-name').value.trim();
                    const type = document.getElementById('edit-competition-type').value;
                    const groupsCount = type === 'cup' ? parseInt(document.getElementById('edit-cup-groups').value) : null;
                    
                    if (!name) {
                        alert('Inserisci il nome del campionato');
                        return;
                    }

                    try {
                        await updateCompetition(competitionId, { name, type, groups_count: groupsCount });
                        await loadCompetitions();
                        await updateEditTeamsList(competitionId);
                        alert('Campionato aggiornato con successo');
                    } catch (error) {
                        alert('Errore nell\'aggiornamento del campionato: ' + error.message);
                    }
                });

                // Event listeners chiusura modals
                document.getElementById('close-teams-creation-modal').addEventListener('click', closeTeamsCreationModal);
                document.getElementById('cancel-teams-creation').addEventListener('click', closeTeamsCreationModal);
                document.getElementById('close-edit-modal').addEventListener('click', closeEditModal);
                document.getElementById('close-edit-competition').addEventListener('click', closeEditModal);
                
                // Event listeners per il modal di modifica risultati
                document.getElementById('edit-results-btn').addEventListener('click', () => {
                    const competitionId = document.getElementById('edit-competition-modal').dataset.competitionId;
                    const competitionName = document.getElementById('edit-competition-name').value;
                    openEditResultsModal(competitionId, competitionName);
                });
                
                document.getElementById('close-edit-results-modal').addEventListener('click', () => {
                    document.getElementById('edit-results-modal').classList.add('hidden');
                });
                
                document.getElementById('close-edit-results').addEventListener('click', () => {
                    document.getElementById('edit-results-modal').classList.add('hidden');
                });
                
                document.getElementById('edit-results-matchday-select').addEventListener('change', (e) => {
                    const matchdayId = e.target.value;
                    if (matchdayId) {
                        loadEditResultsMatches(matchdayId);
                    } else {
                        document.getElementById('edit-results-matches-container').innerHTML = 
                            '<p class="text-gray-500 italic">Seleziona una giornata per vedere le partite</p>';
                        document.getElementById('save-all-results').classList.add('hidden');
                    }
                });
                
                document.getElementById('save-all-results').addEventListener('click', saveAllResults);
                
                document.getElementById('close-match-result-modal').addEventListener('click', () => {
                    document.getElementById('match-result-modal').classList.add('hidden');
                });
                document.getElementById('cancel-match-result').addEventListener('click', () => {
                    document.getElementById('match-result-modal').classList.add('hidden');
                });

                // Event listeners per i tab admin
                document.getElementById('tab-competitions').addEventListener('click', () => {
                    showTab('competitions');
                });
                document.getElementById('tab-calendar').addEventListener('click', () => {
                    showTab('calendar');
                    loadCompetitionSelects();
                });
                document.getElementById('tab-standings').addEventListener('click', () => {
                    showTab('standings');
                    loadCompetitionSelects();
                });

                // Funzione per gestire i tab admin
                function showTab(tabName) {
                    document.querySelectorAll('#admin-section .tab-content').forEach(tab => {
                        tab.classList.add('hidden');
                    });
                    
                    document.querySelectorAll('#admin-section .tab-button').forEach(button => {
                        button.classList.remove('border-yellow-400', 'font-semibold', 'text-yellow-400');
                        button.classList.add('text-gray-300');
                    });
                    
                    document.getElementById(tabName + '-tab').classList.remove('hidden');
                    
                    const activeButton = document.getElementById('tab-' + tabName);
                    activeButton.classList.add('border-yellow-400', 'font-semibold', 'text-yellow-400');
                    activeButton.classList.remove('text-gray-300');
                }

                // Event listeners per il calendario
                document.getElementById('generate-calendar').addEventListener('click', async () => {
                    const competitionId = document.getElementById('calendar-competition-select').value;
                    if (!competitionId) {
                        alert('Seleziona un campionato');
                        return;
                    }
                    
                    // Controlla se esiste gi√† un calendario
                    const existingCalendar = await checkIfCalendarExists(competitionId);
                    if (existingCalendar) {
                        if (!confirm('ATTENZIONE: Esiste gi√† un calendario per questo campionato!\n\nRigenerando il calendario verranno ELIMINATI tutti i risultati inseriti e le giornate esistenti.\n\nSei sicuro di voler continuare?')) {
                            return;
                        }
                    } else {
                        if (!confirm('Vuoi generare il calendario per questo campionato?')) {
                            return;
                        }
                    }
                    
                    await generateCalendarForCompetition(competitionId);
                });

                // Event listener per generare le fasi finali della coppa
                document.getElementById('generate-finals').addEventListener('click', async () => {
                    const competitionId = document.getElementById('calendar-competition-select').value;
                    if (!competitionId) {
                        alert('Seleziona un campionato');
                        return;
                    }
                    
                    // Ottieni il tipo di fase da generare
                    const { data: competition } = await supabaseClient
                        .from('competitions')
                        .select('groups_count')
                        .eq('id', competitionId)
                        .single();

                    const nextPhase = await determineNextPhase(competitionId, competition.groups_count);
                    let confirmMessage = '';
                    
                    switch (nextPhase) {
                        case 'semifinals':
                            confirmMessage = 'Vuoi generare le semifinali basandoti sui risultati dei gironi?';
                            break;
                        case 'finals':
                            confirmMessage = 'Vuoi generare la finale basandoti sui risultati delle semifinali?';
                            break;
                        case 'third_place':
                            confirmMessage = 'Vuoi generare la finale per il 3¬∞ posto?';
                            break;
                        case 'complete':
                            confirmMessage = 'Le fasi finali esistono gi√†.\n\nVuoi rigenerarle? (Questo canceller√† i risultati esistenti)';
                            break;
                        default:
                            alert('Errore nel determinare la fase successiva!');
                            return;
                    }
                    
                    if (!confirm(confirmMessage)) {
                        console.log('üö´ Utente ha annullato la generazione delle fasi finali');
                        return;
                    }
                    
                    console.log('üöÄ Inizio generazione fasi finali...');
                    
                    try {
                        await generateEliminationMatches(competitionId);
                        console.log('‚úÖ Fasi finali generate con successo');
                        
                        // Ricarica il calendario per mostrare le nuove partite
                        await loadCalendar(competitionId);
                        console.log('‚úÖ Calendario ricaricato');
                        
                    } catch (error) {
                        console.error('‚ùå Errore durante la generazione delle fasi finali:', error);
                        showError('‚ùå Errore durante la generazione: ' + error.message);
                        return;
                    }
                    
                    // Aggiorna il testo del pulsante
                    const finalsBtn = document.getElementById('generate-finals');
                    try {
                        const newNextPhase = await determineNextPhase(competitionId, competition.groups_count);
                        switch (newNextPhase) {
                            case 'semifinals':
                                finalsBtn.textContent = 'Genera Semifinali';
                                break;
                            case 'finals':
                                finalsBtn.textContent = 'Genera Finale';
                                break;
                            case 'third_place':
                                finalsBtn.textContent = 'Genera Finale 3¬∞ posto';
                                break;
                            case 'complete':
                                finalsBtn.textContent = 'Rigenera Fasi Finali';
                                finalsBtn.disabled = false;
                                finalsBtn.className = 'bg-orange-600 text-white px-4 py-2 rounded font-semibold hover:bg-orange-700';
                                break;
                        }
                    } catch (error) {
                        console.error('Errore nell\'aggiornamento del pulsante:', error);
                    }
                });

                // Event listener per riparare le fasi finali
                document.getElementById('repair-finals').addEventListener('click', async () => {
                    const competitionId = document.getElementById('calendar-competition-select').value;
                    if (!competitionId) {
                        alert('Seleziona un campionato');
                        return;
                    }

                    if (!confirm('üîß RIPARAZIONE FASI FINALI\n\nQuesta operazione creer√† le giornate mancanti per le fasi finali di questa coppa.\n\n‚ö†Ô∏è NOTA: Verranno create solo le giornate vuote, non le partite.\n\nVuoi continuare?')) {
                        return;
                    }

                    try {
                        // Ottieni informazioni sulla competizione
                        const { data: competition } = await supabaseClient
                            .from('competitions')
                            .select('type, groups_count')
                            .eq('id', competitionId)
                            .single();

                        if (competition.type !== 'cup') {
                            alert('‚ùå Questa funzione √® disponibile solo per le competizioni di tipo "coppa"');
                            return;
                        }

                        // Calcola il prossimo round number
                        const { data: lastMatchday } = await supabaseClient
                            .from('matchdays')
                            .select('round_number')
                            .eq('competition_id', competitionId)
                            .order('round_number', { ascending: false })
                            .limit(1)
                            .single();
                            
                        const nextRoundNumber = lastMatchday ? lastMatchday.round_number + 1 : 1;
                        console.log('üîß Riparazione: prossimo numero giornata:', nextRoundNumber);

                        // Crea le fasi mancanti
                        await createEliminationPhases(competitionId, competition.groups_count, nextRoundNumber);
                        
                        // Ricarica il calendario
                        await loadCalendar(competitionId);
                        
                        // Nascondi il pulsante di riparazione e aggiorna quello principale
                        document.getElementById('repair-finals').style.display = 'none';
                        await updateFinalsButtonText(competitionId, competition.groups_count);
                        
                        showSuccess('‚úÖ Fasi finali riparate con successo! Ora puoi generare le partite.');
                        
                    } catch (error) {
                        console.error('‚ùå Errore durante la riparazione:', error);
                        showError('‚ùå Errore nella riparazione: ' + error.message);
                    }
                });

                // Event listeners per il ricalcolo delle classifiche
                document.getElementById('recalculate-standings').addEventListener('click', async () => {
                    const competitionId = document.getElementById('standings-competition-select').value;
                    if (!competitionId) {
                        alert('Seleziona un campionato');
                        return;
                    }
                    
                    if (!confirm('Vuoi ricalcolare la classifica per questo campionato?')) {
                        return;
                    }
                    
                    try {
                        await updateStandings(competitionId);
                        await loadStandings(competitionId);
                        
                        // Aggiorna anche la classifica pubblica se √® la stessa competizione
                        const publicCompetitionId = document.getElementById('public-competition-select').value;
                        if (publicCompetitionId === competitionId) {
                            await loadPublicStandings(competitionId);
                            await loadPublicStats(competitionId);
                        }
                        
                        alert('Classifica ricalcolata con successo!');
                    } catch (error) {
                        console.error('Errore nel ricalcolo della classifica:', error);
                        alert('Errore nel ricalcolo della classifica: ' + error.message);
                    }
                });

                document.getElementById('recalculate-all-standings').addEventListener('click', async () => {
                    if (!confirm('ATTENZIONE: Vuoi ricalcolare TUTTE le classifiche di TUTTI i campionati?\n\nQuesta operazione potrebbe richiedere diversi secondi.')) {
                        return;
                    }
                    
                    try {
                        // Ottieni tutti i campionati
                        const competitions = await getAllCompetitions();
                        let successCount = 0;
                        let errorCount = 0;
                        
                        for (const competition of competitions) {
                            try {
                                await updateStandings(competition.id);
                                successCount++;
                            } catch (error) {
                                console.error(`Errore nel ricalcolo della classifica per ${competition.name}:`, error);
                                errorCount++;
                            }
                        }
                        
                        // Aggiorna le visualizzazioni correnti
                        const currentAdminCompetition = document.getElementById('standings-competition-select').value;
                        if (currentAdminCompetition) {
                            await loadStandings(currentAdminCompetition);
                        }
                        
                        const currentPublicCompetition = document.getElementById('public-competition-select').value;
                        if (currentPublicCompetition) {
                            await loadPublicStandings(currentPublicCompetition);
                            await loadPublicStats(currentPublicCompetition);
                        }
                        
                        alert(`Operazione completata!\n\n‚úÖ Successi: ${successCount}\n‚ùå Errori: ${errorCount}`);
                    } catch (error) {
                        console.error('Errore nel ricalcolo di tutte le classifiche:', error);
                        alert('Errore nel ricalcolo di tutte le classifiche: ' + error.message);
                    }
                });

                document.getElementById('calendar-competition-select').addEventListener('change', async (e) => {
                    const competitionId = e.target.value;
                    const generateBtn = document.getElementById('generate-calendar');
                    const finalsBtn = document.getElementById('generate-finals');
                    
                    if (competitionId) {
                        // Ottieni informazioni sulla competizione per sapere se √® una coppa
                        const { data: competition } = await supabaseClient
                            .from('competitions')
                            .select('type, groups_count')
                            .eq('id', competitionId)
                            .single();

                        await loadCalendar(competitionId);
                        
                        // Controlla se esiste gi√† un calendario e aggiorna il pulsante
                        const existingCalendar = await checkIfCalendarExists(competitionId);
                        if (existingCalendar) {
                            generateBtn.textContent = 'Rigenera Calendario';
                            generateBtn.className = 'bg-red-600 text-white px-4 py-2 rounded font-semibold hover:bg-red-700';
                        } else {
                            generateBtn.textContent = 'Genera Calendario';
                            generateBtn.className = 'bg-yellow-400 text-green-900 px-4 py-2 rounded font-semibold hover:bg-yellow-300';
                        }

                        // Mostra il pulsante "Genera Fasi Finali" solo per le coppe
                        if (competition && competition.type === 'cup') {
                            // Usa la funzione per aggiornare il testo del pulsante e gestire la visibilit√† del repair
                            await updateFinalsButtonText(competitionId, competition.groups_count);
                        } else {
                            finalsBtn.style.display = 'none';
                            document.getElementById('repair-finals').style.display = 'none';
                        }
                    } else {
                        document.getElementById('calendar-content').innerHTML = '<p class="text-gray-400 italic">Seleziona un campionato per visualizzare il calendario</p>';
                        generateBtn.textContent = 'Genera Calendario';
                        generateBtn.className = 'bg-yellow-400 text-green-900 px-4 py-2 rounded font-semibold hover:bg-yellow-300';
                        finalsBtn.style.display = 'none';
                    }
                });

                document.getElementById('standings-competition-select').addEventListener('change', async (e) => {
                    const competitionId = e.target.value;
                    if (competitionId) {
                        await updateStandings(competitionId);
                        await loadStandings(competitionId);
                    } else {
                        document.getElementById('standings-content').innerHTML = '<p class="text-gray-400 italic">Seleziona un campionato per visualizzare la classifica</p>';
                    }
                });

                // Event listener per il form risultati partita
                document.getElementById('match-result-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const modal = document.getElementById('match-result-modal');
                    const matchId = modal.dataset.matchId;
                    const homeScore = parseInt(document.getElementById('home-score').value);
                    const awayScore = parseInt(document.getElementById('away-score').value);
                    
                    if (isNaN(homeScore) || isNaN(awayScore)) {
                        alert('Inserisci risultati validi');
                        return;
                    }
                    
                    try {
                        await updateMatchResult(matchId, homeScore, awayScore);
                        
                        // Aggiorna automaticamente tutte le visualizzazioni
                        const competitionId = document.getElementById('calendar-competition-select').value;
                        if (competitionId) {
                            await updateStandings(competitionId);
                            await loadCalendar(competitionId);
                            
                            // Aggiorna la classifica pubblica se √® la stessa competizione
                            const publicCompetitionId = document.getElementById('public-competition-select').value;
                            if (publicCompetitionId === competitionId) {
                                await loadPublicStandings(competitionId);
                                await loadPublicStats(competitionId);
                            }
                            
                            // Aggiorna la classifica admin se √® la stessa competizione
                            const adminCompetitionId = document.getElementById('standings-competition-select').value;
                            if (adminCompetitionId === competitionId) {
                                await loadStandings(competitionId);
                            }
                        }
                        
                        modal.classList.add('hidden');
                        showSuccess('Risultato salvato con successo');
                    } catch (error) {
                        alert('Errore nel salvataggio del risultato: ' + error.message);
                    }
                });

                document.getElementById('finish-competition-creation').addEventListener('click', async () => {
                    closeTeamsCreationModal();
                    await loadCompetitionSelects();
                    await loadPublicCompetitions();
                    showSuccess('Campionato creato con successo!');
                });
                
            } catch (error) {
                console.error('‚ùå Errore inizializzazione:', error);
                document.getElementById('auth-message').innerHTML = '‚ùå Errore di inizializzazione: ' + error.message;
            }
        });
    </script>
</body>
</html>
